{
  
  "1": {
    "title": "API",
    "content": "API . The TerminusDB Server HTTP API. JSON documents have optional elements notated with angle-brackets, for instance: . { &lt;&quot;optional&quot; : &quot;foo&quot;&gt;, &quot;required&quot; : &quot;bar&quot; } . . Connect | Create Database | Delete Database | Get Triples | Update Triples | Query | Clone | Fetch | Rebase | Push | Pull | Branch | Create Graph | Delete Graph | . Connect . GET http://localhost:6363/ . The Connect API endpoint returns the system:User object associated with the authentication provided (as documented in the system_schema.owl.ttl ontology). If no authentication is provided, the user will be the predefined terminusdb:///system/data/anonymous user. . Create Database . POST http://localhost:6363/db/&lt;organization&gt;/&lt;dbid&gt; . Post argument is a JSON document of the following form . { &lt; &quot;prefixes&quot; : { &lt; &quot;doc&quot; : Document_Prefix &gt;, &lt; &quot;scm&quot; : Schema_Prefix &gt; } &gt; &quot;label&quot; : &quot;A Label&quot;, &quot;comment&quot; : &quot;A Comment&quot;, &lt; &quot;public&quot; : Boolean &gt;, &lt; &quot;schema&quot; : Boolean &gt; } . Create a new database with database ID dbid for organization organization. . Default prefixes associated with document and schema can be specified. . Both label and comment are required fields, which will be the display name of the database and its description. . The public boolean will determine if this database has read visibility to the anonymous user. It defaults to false. . The schema boolean will determine if this database is created with an empty schema, or if it is running in “schema free” mode. It defaults to false. . Delete Database . DELETE http://localhost:6363/&lt;organization&gt;/&lt;dbid&gt; . Delete the database with organisation and database ID, `dbid`. . Get Triples . GET http://localhost:6363/triples/&lt;organization&gt;/&lt;dbid&gt;/&lt;repo&gt;/branch/&lt;branchid&gt;/&lt;type&gt;/&lt;name&gt;&lt;?format=turtle&gt; GET http://localhost:6363/triples/&lt;organization&gt;/&lt;dbid&gt;/&lt;repo&gt;/commit/&lt;refid&gt;/&lt;type&gt;/&lt;name&gt;&lt;?format=turtle&gt; . This call returns a “Turtle” format file representation of the graph specified in the URL path as a JSON string. It takes a get parameter format which must always be “turtle”. In the future we hope to support other formats. . Update Triples . POST http://localhost:6363/triples/&lt;organization&gt;/&lt;dbid&gt;/local/branch/&lt;branchid&gt;/&lt;type&gt;/&lt;name&gt; . Post argument is a JSON document of the following form . { &quot;turtle&quot; : TTL_String, &quot;commit_info&quot; : { &quot;author&quot; : Author, &quot;message&quot; : Message } } . This call creates the update required to make the graph referred to in the URL have exactly the triples specified in the turtle field of the JSON document. It must be supplied with a commit message (though it can be an empty string). . Query . POST http://localhost:6363/woql POST http://localhost:6363/woql/&lt;organization&gt;/&lt;dbid&gt; POST http://localhost:6363/woql/&lt;organization&gt;/&lt;dbid&gt;/_meta POST http://localhost:6363/woql/&lt;organization&gt;/&lt;dbid&gt;/&lt;repo&gt; POST http://localhost:6363/woql/&lt;organization&gt;/&lt;dbid&gt;/&lt;repo&gt;/_commits POST http://localhost:6363/woql/&lt;organization&gt;/&lt;dbid&gt;/&lt;repo&gt;/branch/&lt;branchid&gt; POST http://localhost:6363/woql/&lt;organization&gt;/&lt;dbid&gt;/&lt;repo&gt;/commit/&lt;refid&gt; . Post argument is a JSON document of the following form . { &lt;&quot;commit_info&quot; : { &quot;author&quot; : Author, &quot;message&quot; : Message } &gt;, &quot;query&quot; : Query } . The commit message is a requirement if an update is being made, whereas query should be a JSON-LD object as specified by the ontology woql.owl.ttl. . This API call performs a WOQL query and returns an api:WoqlResponse result object, which has the form: . { &quot;@type&quot; : &quot;api:WoqlResponse&quot;, &quot;api:status&quot; : &quot;api:success&quot;, &quot;api:variable_names&quot; : Variable_Names, &quot;bindings&quot; : Bindings, &quot;inserts&quot; : Number_Of_Inserts, &quot;deletes&quot; : Number_Of_Deletes, &quot;transaction_retry_count&quot; : Retries } . Clone . POST http://localhost:6363/clone/&lt;organization&gt;/[&lt;new_dbid&gt;] . The JSON payload is: . { &quot;comment&quot; : Comment, &quot;label&quot; : Label, &quot;remote_url&quot; : Remote, &lt; &quot;public&quot; : Bool &gt; } . The API call creates a new database under the same DB ID as the cloned database, or with the new database ID new_dbid if provided. . The other options are exactly as with create db. . Fetch . POST http://localhost:6363/fetch/&lt;organization&gt;/&lt;dbid&gt; . Fetches new layers from the remotes for this database along with the commit history. . Rebase . POST http://localhost:6363/rebase/&lt;organization&gt;/&lt;dbid&gt;[/&lt;repo&gt;/branch/&lt;branchid&gt;] . The JSON payload is: . { &quot;rebase_from&quot; : Resource, &quot;author&quot; : Author, } . The rebase_from contains an absolute string descriptor for the reference we are rebasing from. It may be a ref or a branch. Author should be the author of the newly produced commits. . This operation will attempt to construct a new history which has the same contents as that given by “rebase_from” by repeated application of diverging commits. . Push . POST http://localhost:6363/push/&lt;organization&gt;/&lt;dbid&gt;[/&lt;repo&gt;/branch/&lt;branchid&gt;/] . Pushes deltas from this database to the remote repository. . Pull . POST http://localhost:6363/push/&lt;organization&gt;/&lt;dbid&gt;[/&lt;repo&gt;/branch/&lt;branchid&gt;/] . JSON API document is: . { &quot;remote&quot; : Remote_Name, &quot;remote_branch&quot; : Remote_Branch_Name } . Fetch layers from remote, then attempt a rebase from the remote branch remote_branch onto the local branch specified in the URL. . Branch . POST http://localhost:6363/branch/&lt;organization&gt;/&lt;dbid&gt;/&lt;repo&gt;/&lt;new_branchid&gt; . JSON API document is: . { &lt;&quot;origin&quot; : Remote_Name &gt; } . Creates a new branch as specified by the URI, starting from the branch given by origin or empty if it is unspecified. . Create Graph . POST http://localhost:6363/graph/&lt;organization&gt;/&lt;dbid&gt;/&lt;repo&gt;/branch/&lt;branchid&gt;/&lt;instance|schema|inference&gt;/&lt;graphid&gt; . This takes a post parameter: . {&quot;commit_info&quot; : { &quot;author&quot; : Author, &quot;message&quot; : Message }} . This API call creates a new graph as specified by the absolute graph descriptor in the URI. . Delete Graph . DELETE http://localhost:6363/graph/&lt;organization&gt;/&lt;dbid&gt;/&lt;repo&gt;/branch/&lt;branchid&gt;/&lt;instance|schema|inference&gt;/&lt;graphid&gt; . This takes a post parameter: . {&quot;commit_info&quot; : { &quot;author&quot; : Author, &quot;message&quot; : Message }} . This API deletes the graph specified by the absolute graph descriptor in the URI. .",
    "url": "/docs/reference/server/api/",
    "relUrl": "/reference/server/api/"
  }
  ,"2": {
    "title": "Basic Ideas",
    "content": "Basic Ideas . TerminusDB is an open-source model driven RDF graph database for knowledge graph representation designed specifically for the web-age. . TerminusDB Server provides TerminusDB with a RESTful API for interacting with knowledge graphs via the JSON-LD exchange format. This means you can easily compose applications within your own toolchain which utilize the powerful features of graph search and graph storage. . We use an advanced git-like model, storing append only changes to graphs represented in succinct data structures. You can read a description of the architecture in our Succinct Data Structures and Delta Encoding for Modern Databases whitepaper. . TerminusDB’s delta-encoding approach makes possible branch, merge, push, pull, clone, time-travel and other git-like operations on a fully-featured graph database. . Here are some posts: . Technical history of the development of TerminusDB | Continuous Everything as Code . . |",
    "url": "/docs/discussion/baisc/",
    "relUrl": "/discussion/baisc/"
  }
  ,"3": {
    "title": "Accessing TerminusHub with Bootstrap - Certificate Help",
    "content": "Accessing TerminusHub with Bootstrap - Certificate Help . You can access the Bootstrap through the TerminusDB Download Center . Requirements . Requirements: Git, Bash and Docker . Windows users: Git Bash and Docker . Installing . Clone terminusdb-bootstrap and enter the directory: . git clone https://github.com/terminusdb/terminusdb-bootstrap.git cd terminusdb-bootstrap git checkout rc . Run the following command to change the default options, to be part of our beta . echo &quot; # shellcheck shell=sh # shellcheck disable=SC2034 # # ENVIRONMENT # # To persist environment settings copy this file to ENV # # Docker command #TERMINUSDB_DOCKER=sudo docker # Container #TERMINUSDB_CONTAINER=terminusdb-server #TERMINUSDB_REPOSITORY=terminusdb/terminusdb-server #TERMINUSDB_NETWORK=bridge #TERMINUSDB_LABEL_FILE=labels # Version #TERMINUSDB_TAG=beta # Name of Docker Storage Volume #TERMINUSDB_STORAGE=terminusdb_storage_local # Container Port to Publish #TERMINUSDB_PORT=6363 # Local Directory to Mount inside Container #TERMINUSDB_LOCAL=/home/username/localfiles # URL To TermiunusDB Console #TERMINUSDB_CONSOLE_BASE_URL=//127.0.0.1:3005 # Server #TERMINUSDB_AUTOLOGIN=false #TERMINUSDB_PASS=root #TERMINUSDB_SERVER_IP=127.0.0.1 #TERMINUSDB_CONSOLE=http://127.0.0.1/console # HTTPS TERMINUSDB_HTTPS_ENABLED=true #TERMINUSDB_SSL_CERT=/etc/letsencrypt/live/example.com/fullchain.pem #TERMINUSDB_SSL_CERT_KEY=/etc/letsencrypt/live/example.com/privkey.pem # vim:ft=sh &quot; &gt; ENV . Run ./terminusdb-container run . You should be able to access terminusdb on https://127.0.0.1:6363/ . Unfortunately, the browser will give you a certificate warning. Do not worry, since the server is running on your own machine, nobody is intercepting your traffic. .",
    "url": "/docs/how-tos/beta/",
    "relUrl": "/how-tos/beta/"
  }
  ,"4": {
    "title": "Create and Merge Branches in Python",
    "content": "Create and Merge Branches . . Branch | Merging (rebase) branches | . Branch . First, we need to connect to our TerminusDB server and an existing database. . server_url = &quot;https://127.0.0.1:6363&quot; db = &quot;My_DB&quot; user = &quot;admin&quot; account = &quot;admin&quot; key = &quot;root&quot; repository = &quot;local&quot; client = WOQLClient(server_url) client.connect(user=user, account=account, key=key, db=db) . If we want to branch from the current head on branch main, all that is required is to execute the following: . client.branch(&#39;new_branch&#39;) . If we instead want to branch from a different branch head (which must already exist) we can do the following: . client.checkout(&#39;other_branch&#39;) client.branch(&#39;new_branch&#39;) . Branching does not move you to the new branch! You need to do that manually with checkout. For instance: . client.checkout(&#39;new_branch&#39;) . Merging (rebase) branches . Once we have two branches, we can rebase one into the other. This will leave us with a branch that has all of the data from both branches. . If we want to rebase new_branch on top of other_branch, we can do the following: . client.checkout(&#39;other_branch&#39;) branch = &#39;new_branch&#39; client.rebase({&quot;rebase_from&quot;: f&#39;{user}/{db}/{repository}/branch/{branch}&#39;, &quot;author&quot;: user, &quot;message&quot;: f&quot;Merging {branch} into other_branch&quot;}) . And then you should have all of the content from old_branch present in new_branch! .",
    "url": "/docs/how-tos/python/branch-python/",
    "relUrl": "/how-tos/python/branch-python/"
  }
  ,"5": {
    "title": "Creating and Merging Branches",
    "content": "Create and Merge Branches . TerminusDB is designed to enable collaboration and revision control on data assets. While git is a fantastic piece of software, it is designed for code management, and not data management. We bring that power to the world of data. . In order to get a feel for how these collaboration features work, we can start with a classic database management problem: the bank account balance. . This tutorial will show you how to use the branch and merge functions in TerminusDB. . . Section 1 - Schema and Data . Create a new database with the ID banker and the name “bank”, in the console. Select ‘Create on TerminusHub’. . . Once created you should land in the DB Home page. . The first thing we need to do is define a data model. To do this, click on the Query button at the top and enter the following query, along with a comment “New schema”. . WOQL.doctype(&quot;BankAccount&quot;).label(&quot;Bank Account&quot;) .property(&quot;owner&quot;,&quot;xsd:string&quot;) .label(&quot;owner&quot;) .cardinality(1) .property(&quot;balance&quot;,&quot;xsd:nonNegativeInteger&quot;) .label(&quot;balance&quot;) .cardinality(1) . This query creates a new document type “BankAccount” along with two properties, one named “owner” which is a string, and one named balance. Both have a cardinality of 1. . . If you click on the “Bank Balance Example” button on the top of the screen, it will bring you back to the revision overview and you should be able to see what changes you have made. . Data Entry . Ok, so far so good, but we’ve no data. Now it is time to try and put some data in the db. . Let’s go to the query screen and write the following query: . WOQL.and( WOQL.add_triple(&quot;doc:mike&quot;, &quot;type&quot;, &quot;scm:BankAccount&quot;), WOQL.add_triple(&quot;doc:mike&quot;, &quot;owner&quot;, &quot;mike&quot;), WOQL.add_triple(&quot;doc:mike&quot;, &quot;balance&quot;, 123) ) . This adds some data to our database. You can click on the Documents page and you will see, that in fact mike was added. . Now we should try to make some edits to the bank account to see what happens. . First, let’s try and subtract 130 dollars from Mike’s account. . vars = function(sl) {return sl.map( s =&gt; &quot;v:&quot; + s)} let [balance,new_balance] = vars([&quot;Balance&quot;, &quot;New Balance&quot;]) WOQL.and( WOQL.triple(&quot;doc:mike&quot;, &quot;scm:balance&quot;, balance), WOQL.delete_triple(&quot;doc:mike&quot;, &quot;scm:balance&quot;, balance), WOQL.eval(WOQL.minus(balance, 130), new_balance), WOQL.add_triple(&quot;doc:mike&quot;, &quot;scm:balance&quot;, new_balance) ) . This query fails with the following JSON-LD witness object: . . This tells us that our bank balance is invalid as it is negative! TerminusDB doesn’t allow the transaction to go through. . However, we can change the balance by subtracting a smaller number: . vars = function(sl) {return sl.map( s =&gt; &quot;v:&quot; + s)} let [balance,new_balance] = vars([&quot;Balance&quot;, &quot;New Balance&quot;]) WOQL.and( WOQL.triple(&quot;doc:mike&quot;, &quot;scm:balance&quot;, balance), WOQL.delete_triple(&quot;doc:mike&quot;, &quot;scm:balance&quot;, balance), WOQL.eval(WOQL.minus(balance, 13), new_balance), WOQL.add_triple(&quot;doc:mike&quot;, &quot;scm:balance&quot;, new_balance) ) . Press “Query” and see the result: . . Now we have a balance of 13 as expected and everything works fine. . . Section 2 - Branch and Merge . Branching . Now that we have some data and some updates, we can go ahead and try creating a branch. A branch starts a new database from a particular commit, allowing us to change the database without affecting the original database. . This can be used to make isolated changes and test them, before we merge them back into the original. . Ok, so go click on the “Branch” button. . Under the field “New Branch ID” enter in “branch_office” and we’ll pretend we have a branch office adding accounts. . . Now go to the query page. If you look up at the top right of the interface, you’ll see we are still on “branch: main”. Pull the selector down to “branch: branch_office”. . Now we can enter the following query: . WOQL.and( WOQL.add_triple(&quot;doc:jim&quot;, &quot;type&quot;, &quot;scm:BankAccount&quot;), WOQL.add_triple(&quot;doc:jim&quot;, &quot;owner&quot;, &quot;jim&quot;), WOQL.add_triple(&quot;doc:jim&quot;, &quot;balance&quot;, 8) ) . This creates Jim, with all 8 dollars to his name. If we now go to the Documents tab we can see that Jim and Mike’s bank account are both listed now. . . Rebase . Let’s go back to the original branch (main), by selecting it in the upper right hand corner, and add one more person, jane in the main branch so that we now have two different histories, with one common commit. . WOQL.and( WOQL.add_triple(&quot;doc:jane&quot;, &quot;type&quot;, &quot;scm:BankAccount&quot;), WOQL.add_triple(&quot;doc:jane&quot;, &quot;owner&quot;, &quot;jane&quot;), WOQL.add_triple(&quot;doc:jane&quot;, &quot;balance&quot;, 887) ) . Jane was a bit more frugal and has saved 887 dollars. . . But we’re still missing the information about jim, as it’s stuck in the branch office. How do we get the information into our main branch? . This is why we have merge. Click the “Branch” button and click on Merge. . . Select the “branch_office” branch in the upper right hand corner. Now select the “merge into” branch as “main”. . . Now we should go back to the main branch (again in the upper right hand corner), and select the documents view. You’ll see that we have merged the two databases together! . . That’s how easy it is to manage complex data with TerminusDB and TerminusHub. .",
    "url": "/docs/tutorials/branch-tutorial/",
    "relUrl": "/tutorials/branch-tutorial/"
  }
  ,"6": {
    "title": "Branching and Merging",
    "content": "Branching and Merging . Branching means you diverge from the mainline of the database and can continue to do work without messing with that mainline. This, with merge, is a killer feature for TerminusDB and TerminusHub. . A branch in TerminusDB is simply a lightweight movable pointer to a commit. The default database name in TerminusDB is main. . When you make a commit, stores a commit object that contains a pointer to the snapshot of the content you staged. . Merge Strategies . Currently, we have only implemented a single strategy for merging branches. This strategy is called rebase. We intend to include other approaches to merge in the near future. . Rebase . Rebase is a merge style which takes the commits from a source branch and places all new commits (those which follow from the common history of it exists) on the top of the current head. This allows users to create a common view of history which plays new work on top of that which has already been commited by others. This can be convenient when collaborating with other users. . Here are some posts: . Branch and Merge Functionality in TerminusDB and Hub |",
    "url": "/docs/discussion/branch/",
    "relUrl": "/discussion/branch/"
  }
  ,"7": {
    "title": "Create and Merge Branches",
    "content": "Create and Merge Branches . TerminusDB and TerminusHub provide powerful tools that make it easy to create and share branches in databases. But eventually these branches have to be merged back together - TerminusDB makes this process easy. . These tools are also central to the coordination of a team, all working on a common database or set of databases. By recording the changes each engineer and scientist makes, TerminusDB can keep track of many lines of work at once, and help engineers and scientist work out how to merge these lines of work together. . This How To uses the TerminusDB console. . . Section 1 - Branch . From the ‘DB Home’ screen on your database, click on the ‘Branch’ tab. Once there, click the ‘Branch’ button under ‘Create a new Branch’. . . On the next screen insert the name of the new branch into the ‘New Branch ID’ box and click ‘Create New Branch’. In this case, we have called the new branch ‘branch_office’. . . You will now be able to see that a new branch appears in the top right drop down menu. . . . Section 1 - Merge . Click on the ‘Branch’ tab and click the ‘Merge’ button under ‘Merge Branches’. You will now be on the merge screen. You should select the branch you want to merge in the top right drop down and the correct branch to merge into in the ‘Merge Into Branch’ drop down. Once you are happy that these are correct, you can click ‘Merge into x Branch’ button (in the below example, it is ‘Merge into Main Branch’ as we are merging the ‘branch_office’ into ‘main’). . . You can now check to confirm that the data from the branches has been merged. . Without branching and merging, we give individuals the illusion of frozen time, that they are the only ones changing the system and those changes can wait until they are fully baked before risking the system. But this is an illusion and eventually the price for it comes due. Who pays? When? How much? .",
    "url": "/docs/how-tos/branch/",
    "relUrl": "/how-tos/branch/"
  }
  ,"8": {
    "title": "My First Cloned Database",
    "content": "My First Cloned Database . This tutorial will show you how to clone a database in TerminusDB and Hub console. Once you have downloaded TerminusDB and set up your account, cloning a database should take less than a minute. . . Step 1 - Login to TerminusDB and Go to Clone Screen . Go to the TerminusDB home page and login to TerminusHub by clicking Connect to Hub: . . You will now be in the logged in environment and should click clone: . . On the clone screen, click the cloud beside the bike sharing database to clone the DB . . You can also click on the title of the database TerminusDB Bike Tutorial to get to the clone screen. In this screen you also have the option to ‘fork’ the database which creates your own copy of the database. You may want your own copy if you want to make changes to the database. . . . Step 2 - Clone and Review . Now that you have clicked the clone button, you will be taken to the home screen of the bike sharing database: . . You can now explore the database by reviewing the commit history or looking at the database’s schema and documents. . . . Step 3 - Running a Query . Now click on the query button to run a quick query against the database. . . This query is taken from the bike data tutorial : . WOQL.select(&quot;v:Start&quot;, &quot;v:Start_Label&quot;, &quot;v:End&quot;, &quot;v:End_Label&quot;).and( WOQL.triple(&quot;v:Journey&quot;, &quot;type&quot;, &quot;scm:Journey&quot;), WOQL.triple(&quot;v:Journey&quot;, &quot;start_station&quot;, &quot;v:Start&quot;), WOQL.opt().triple(&quot;v:Start&quot;, &quot;label&quot;, &quot;v:Start_Label&quot;), WOQL.triple(&quot;v:Journey&quot;, &quot;end_station&quot;, &quot;v:End&quot;), WOQL.opt().triple(&quot;v:End&quot;, &quot;label&quot;, &quot;v:End_Label&quot;), WOQL.triple(&quot;v:Journey&quot;, &quot;journey_bicycle&quot;, &quot;v:Bike&quot;) ) . You can now click on result viewer to see the result of the query and click on the drop down menu on the right hand side to switch to a graph view. . . . And that is how easy it is to clone a complex database and immediately run a query against the database. . Enjoy! .",
    "url": "/docs/tutorials/clone-tutorial/",
    "relUrl": "/tutorials/clone-tutorial/"
  }
  ,"9": {
    "title": "Collaboration",
    "content": "Collaboration . TerminusDB contains a powerful query engine and API, but what makes it most unique, is its revision control capabilities which were built into the very core of how TerminusDB works. In the most technical terms, TerminusDB uses an immutable append-only layered storage model where only state differences are stored, using a succinct delta-encoding mechanism. In simple terms, TerminusDB never changes anything - whenever you update the database, new values are created which shadow the old ones but you can always look behind the shadow and see what everything looked like before each and every update. The entire history of everything that has ever been in the database is retained and readily accessible. . Once you have a database engine that works like this, it becomes relatively easy and lightweight to provide the core revision control operations - branch, merge, push and pull (or some variation thereof) that practical revision control systems must provide. . This basic idea and much of the revision control functionality has been shamelessly borrowed from Git - the version control tool that has improved all of our lives immeasurably as software engineers. Where we have gone beyond git is that TerminusDB is designed for data not code - specifically and most importantly, in addition to providing all of the revision control functionality that git provides, TerminusDB also supports fast queries over very large (multi-billion node) highly complex datasets with an extremely expressive and formally correct query and schema language. . By marrying the scale and querying capabilities of a modern in-memory graph database with the revision control functionality of git, we hope to provide relief to every engineer who ever looked at a pile of huge CSVs and said to themselves, “there must be a better way of doing this, if only there was a git for data”. . Here are some posts: . Continuous Everything as Code | My First Shared TerminusDB with TerminusHub |",
    "url": "/docs/discussion/collaboration/",
    "relUrl": "/discussion/collaboration/"
  }
  ,"10": {
    "title": "Configuration",
    "content": "Configuration . (intro to what this page is about) . . Section 1 | Section 2 | . Section 1 . content of section 1 . Section 2 . content of section 2 . etc .",
    "url": "/docs/reference/web-components/configuration/",
    "relUrl": "/reference/web-components/configuration/"
  }
  ,"11": {
    "title": "Client - Core Functions",
    "content": "Client core functions . . Import Script | NPM: WOQLClient Class | TerminusDB Client API Connect | Create Database | Delete Database | Create Graph | Delete Graph | Get Triples | Update Triples | Query | Clonedb | Branch | Rebase | Pull | Push | Fetch | | Accessing and Changing Client Context organization | db | repo | checkout | ref | | How Context Affects API Calls | Setting and Getting Client Configuration Options server | api | uid | user_organization | local auth | remote auth | databases | get database | author | set system db | set | | Utility Functions copy | resource | | | . Import Script . NPM: . NPM: . import TerminusClient from &#39;@terminusdb/terminusdb-client&#39; . Script: . &lt;script .../&gt; . WOQLClient Class . The core functionality of the TerminusDB javascript client is defined in the WOQLClient class - in the woqlClient.js file. This class provides methods which allow you to directly get and set all of the configuration and API endpoints of the client. The other parts of the WOQL core - connectionConfig.js and connectionCapabilities.js - are used by the client to store internal state - they should never have to be accessed directly. For situations where you want to communicate with a TerminusDB server API, the WOQLClient class is all you will need. . Basic Usage: . Example let client = new TerminusClient.Client(SERVER_URL, opts) await client.connect(server, opts) client.db(&quot;test&quot;) client.checkout(&quot;dev&quot;) let turtle = await client.getTriples(&quot;schema&quot;, &quot;main&quot;) . The client has an internal state which defines what organization / database / repository / branch / ref it is currently attached to . TerminusDB Client API . Connect . client.connect(server, options) . Description: Connect to a TerminusDB server and retrieve information about the current user’s capabilities and resources on the server. . Status: stable . Arguments: . server: (string) URL of the TerminusDB server to connect to | options: (json) options for connect organization: (string) the id of the organization to connect to (in desktop use, this will always be “admin”) | db: (string) the id of the database to connect to | local_auth: (json) a local auth configuration used to authenticate the client to the local server | key: (string) basic auth password | user: (string) basic auth username (always admin in desktop mode) | remote_auth: (json) a remote auth configuration - passed to the server to authenticate itself to remote servers during pull / push / clone / fork / fetch | branch: (string) id of branch to connect to (defaults to main) | ref: (string) id of the commit to connect to (defaults to head) | repo: (string) id of the repository to connect to (defaults to local) | . | . Return Type: . a JSON-LD document of system:User class [link] | . Example: . client.connect(&quot;https://127.0.0.1:6363/&quot;, {key=&quot;root&quot;}) . Create Database . client.createDatabase(dbid, doc, orgid) . Description: Creates a new database in TerminusDB server . Status: stable . Arguments: . dbid: (string - mandatory) The id of the new database to be created | doc: (json - mandatory) a json object containing details of the database to be created: label (string - mandatory) the display name of the database | comment (string - mandatory) text describing the database | prefixes (json - optional) json containing: doc: (string) the IRI to use when doc: prefixes are expanded (defaults to terminusdb:///data) | scm: (string) the IRI to use when scm: prefixes are expanded (defaults to terminusdb:///schema) | . | schema (boolean - optional) if set to true, a main schema graph will be created, if not set, only a main instance graph will be created orgid: (string - optional) the id of the organization to create the database within (in desktop use, this should always be “admin”) | . | . Returns Promise: HTTP 200 status on success, HTTP error code on failure . Example: . client.createDatabase(&quot;mydb&quot;, {label: &quot;My Database&quot;, comment: &quot;Testing&quot;, schema: true}) . Delete Database . client.deleteDatabase(dbid, orgid) . Description: Deletes a database from a TerminusDB server . Status: stable . Arguments: . dbid: (string - mandatory) The id of the database to be deleted | orgid: (string - optional) the id of the organization to which the database belongs (in desktop use, this will always be “admin”) | . Returns HTTP 200 status on success, HTTP error code on failure . Example . client.deleteDatabase(&quot;mydb&quot;) . Returns Promise: HTTP 200 status on success, HTTP error code on failure . Create Graph . client.createGraph(type, gid, commit_msg) . Description: Creates a new named graph within a TerminusDB database . Status: stable . Arguments: . type: (string - mandatory) - type of graph to create, either “instance”, “schema” or “inference” | gid: (string - mandatory) - id of the graph to be created | commit_msg (string - optional) - a message describing the reason for the change that will be written into the commit log | . Returns Promise: HTTP 200 status on success, HTTP error code on failure . Example . client.createGraph(&quot;schema&quot;, &quot;alt&quot;, &quot;Adding new schema graph&quot;) . Delete Graph . client.deleteGraph(type, gid, commit_msg) . Description: Deletes a graph from a TerminusDB database . Status: stable . Arguments: . type: (string - mandatory) - type of graph to create, either “instance”, “schema” or “inference” | gid: (string - mandatory) - id of the graph to be created | commit_msg (string - optional) - a message describing the reason for the change that will be written into the commit log | . Returns Promise: HTTP 200 status on success, HTTP error code on failure . Example . client.deleteGraph(&quot;schema&quot;, &quot;alt&quot;, &quot;Deleting alt schema graph&quot;) . Get Triples . client.getTriples(gtype, gid) . Description: Retrieve the contents of a graph within a TerminusDB as triples, encoded in the turtle (ttl) format . Status: stable . Arguments: . gtype: (string - mandatory) - type of graph to get triples from, either “instance”, “schema” or “inference” | gid: (string - mandatory) - id of the graph to read from | . Returns Promise: HTTP 200 status on success with the contents being a string representing a set of triples in turtle (ttl) format, HTTP error code on failure . Example . let turtle = await client.getTriples(&quot;schema&quot;, &quot;alt&quot;) . Update Triples . client.updateTriples(gtype, gid, turtle, commit_msg) . Description: Replace the contents of the specified graph with the passed triples encoded in the turtle (ttl) format . Status: stable . Arguments: . gtype: (string - mandatory) - type of graph to get triples from, either “instance”, “schema” or “inference” | gid: (string - mandatory) - id of the graph to read from | turtle: (string - mandatory) - string encoding triples in turtle (ttl) format | commit_msg (string - optional) - a message describing the reason for the change that will be written into the commit log | . Returns Promise: HTTP 200 status on success, HTTP error code on failure . Example . client.updateTriples(&quot;schema&quot;, &quot;alt&quot;, turtle_string, &quot;dumping triples to graph alt&quot;) . Query . client.query(woql, commit_msg) . Description: send a Web Object Query Language query to the server . Status: stable . Arguments: . woql: (WOQLQuery Object - mandatory) - an instance of the WOQLQuery class | commit_msg (string - optional) - a message describing the reason for the change that will be written into the commit log (only relevant if the query contains an update) | . Returns Promise: HTTP 200 status on success, contents being a WOQL Query Response, HTTP error code on failure . api:WoqlResponse bindings: (Array) - an array of json values, each representing a single result, with each being indexed by variables | api:variable_names: (Array) - an array of strings, which shows the order in which variables were used in the query | deletes: (int) - the number of triples that were deleted by the query | inserts: (int) - the number of triples that were inserted by the query | transaction_retry_count: (int) - the number of times the transaction was restarted due to contention | . | . Example: . let result = await client.query(WOQL.star()) . Clonedb . client.clonedb(clone_source, newid, orgid) . Description: Clones a remote DB to the local server . Status: Stable . Arguments: . clone_source: (json - mandatory) json describing the source branch to be used as a base remote_url: (string - mandatory) - The URL of the database to be cloned (the URL is always of the form https://server/organization_id/database_id ) | label (string - mandatory) the display name of the new cloned database | comment (string - mandatory) text describing the new cloned database | . | newid: (string - mandatory) id of the new cloned database on the local server | orgid: (string - optional) id of the local organization that the new cloned database will be created in (in desktop mode this is always “admin”) | . Example: . client.clonedb({remote_url: &quot;https://my.terminusdb.com/myorg/mydb&quot;, label &quot;Cloned DB&quot;, comment: &quot;Cloned from mydb&quot;}, newid: &quot;mydb&quot;) . Branch . client.branch(new_branch_id) . Description: creates a new branch with a TerminusDB database, starting from the current context of the client (branch / ref) . Status: Stable . Arguments: . new_branch_id: (string - mandatory) - the ID of the new branch to be created | . Returns Promise: HTTP 200 status on success, HTTP error code on failure . Example . client.branch(&quot;dev&quot;) . Rebase . client.rebase(rebase_source) . Description: Merges the passed branch into the current one using the rebase operation . Status: Stable . Arguments: . rebase_source: (json - mandatory) json describing the source branch to be used as a base rebase_from: (string - mandatory) - branch id to be rebased from | message (string - optional) - a message describing the reason for the change that will be written into the commit log | . | . Example: . client.rebase({rebase_from: &quot;dev&quot;, message: &quot;Merging from dev&quot;) . Pull . client.pull(remote_source_descriptor) . Description: Pull changes from a branch on a remote database to a branch on a local database . Status: Stable . Arguments: . remote_source_descriptor: (json - mandatory) an object describing the source of the pull remote: (string - mandatory) - the id of the remote repo (normally origin) | remote_branch: (string - mandatory) - the id of the remote branch to pull from | message (string - optional) - a message describing the reason for the change that will be written into the commit log | . | . Returns Promise: HTTP 200 status on success, HTTP error code on failure . Example . client.pull({remote: &quot;origin&quot;, remote_branch: &quot;main&quot;, message: &quot;Pulling from remote&quot;}) . Push . client.push(remote_target_descriptor) . Description: Push changes from a branch on a local database to a branch on a remote database . Status: Stable . Arguments: . remote_target_descriptor: (json - mandatory) an object describing the target of the push remote: (string - mandatory) - the id of the remote repo (normally origin) | remote_branch: (string - mandatory) - the id of the remote branch to push to | message (string - optional) - a message describing the reason for the change that will be written into the commit log | . | . Returns Promise: HTTP 200 status on success, HTTP error code on failure . Example . client.push({remote: &quot;origin&quot;, remote_branch: &quot;main&quot;, message: &quot;Pulling from remote&quot;}) . Fetch . client.fetch(remote_id) . Description: Fetch updates to a remote database to a remote repository with the local database . Status: Stable . Arguments: . remote_id (string - required) the id of the remote to fetch (normally origin) | . Returns Promise: HTTP 200 status on success, HTTP error code on failure . Accessing and Changing Client Context . The client’s has an internal context which defines which allows the user to invoke the API actions against any valid resource in the database. For example, by specifying a particular commit id as the source of a query operation, all queries will be made against the state of the database as it was immediately after that specific commit was completed. All of these methods are both getters and setters with 0 or 1 arguments - if no argument is supplied, they get the current value, if an argument is supplied they set the current value for that part of context . Methods . organization | db | repo | checkout | ref | . organization . client.organization(orgid) . Description: Gets and Sets the client’s internal organization context value . Status: Stable . Arguments: . orgid: (string - optional) the organization id to set the context to | . Returns . (string) the current organization id within the client context | . Example . client.organization(&quot;admin&quot;) . db . client.db(dbid) . Description: Gets and Sets the client’s internal db context value . Status: Stable . Arguments: . dbid: (string - optional) the database id to set the context to | . Returns . (string) the current database id within the client context | . Example . client.db(&quot;mydb&quot;) . repo . client.repo(repoid) . Description: Gets and Sets the client’s internal repository context value (defaults to ‘local’) . Status: Stable . Arguments: . repoid: (string - optional) the repository id to set the context to | . Returns . (string) the current repository id within the client context | . Example . client.repo(&quot;origin&quot;) . checkout . client.checkout(branch_id) . Description: Gets and Sets the client’s internal branch context value (defaults to ‘main’) . Status: Stable . Arguments: . branch_id: (string - optional) the branch id to set the context to | . Returns . (string) the current branch id within the client context | . Example . client.checkout(&quot;dev&quot;) . ref . client.ref(commit_id) . Description: Gets and Sets the client’s internal ref context value (defaults to false) . Status: Stable . Arguments: . commit_id: (string - optional) the commit id to set the context to | . Returns . (string) the current commit id within the client context | . Example . client.ref(&quot;mkz98k2h3j8cqjwi3wxxzuyn7cr6cw7&quot;) . How Context Affects API Calls . API Call organization db repo checkout ref . connect | set organization context | set db context | set repo context | set branch context | set commit context | . createDatabase | db created in organization | NA | NA | NA | NA | . deleteDatabase | db deleted from organization | Database to be deleted | NA | NA | NA | . createGraph | db from organization | Database for operation | local | graph created in branch | NA | . deleteGraph | db from organization | Database for operation | local | graph deleted in branch | NA | . getTriples | db from organization | Database for operation | Repository for operation | branch for operation | commit base for operation* | . updateTriples | db from organization | Database for operation | local | NA | NA | . query | db from organization | Database for operation | Repository for operation | branch to be queried | commit root for query* | . clonedb | db from organization | Database for operation | local | NA | NA | . branch | db from organization | Database for operation | Repository of branch origin | branch (head) of origin | commit id of branch origin* | . rebase | db from organization | Database for operation | Repository of rebase target | rebase to target branch | NA | . push | db from organization | Database for operation | local | push from branch | NA | . pull | db from organization | Database for operation | local | pull to branch | NA | . fetch | db from organization | Database for operation | NA | NA | NA | . note ref and checkout are mutually exclusive - if the ref is set it will be used and the branch will be ignored | . Setting and Getting Client Configuration Options . server | api | uid | user_organization | local_auth | remote_auth | databases | get_database | author | set_system_db | set | . server . client.server() . Description: Retrieve the URL of the server that we are currently connected to . Status: Stable . Arguments: None . Returns: . (string) the URL of the TerminusDB server endpoint we are connected to | . Example: . let server_url = client.server() . api . client.api() . Description: Retrieve the URL of the server’s API base that we are currently connected to . Status: Stable . Arguments: None . Returns: . (string) the URL of the TerminusDB server api endpoint we are connected to (typically server() + “api/”) | . Example: . let api_url = client.api() . uid . client.uid() . Description: Retrieve the id of the user that is logged in with the client . Status: Stable . Arguments: None . Returns: . (string) the id of the current user (always ‘admin’ for desktop client) | . Example: . let server_url = client.server() . user_organization . client.user_organization() . Description: Retrieve the id of the organization that the user currently belongs to . Status: Stable . Arguments: None . Returns: . (string) the id of the current user (always ‘admin’ for desktop client) | . Example: . let org = client.user_organization() . local auth . client.local_auth(credentials) . Description: Gets / sets the credentials for connecting to the local terminusdb-server . Status: Stable . Arguments: . credentials: (json - optional) the credentials to use to authenticate to local TerminusDB server type: (string - mandatory) either “jwt” or “basic” | key: (string - mandatory) either the jwt token or the basic auth password depending on the type field | user: (string - optional) the user id to use for basic authentication - defaults to “admin” Returns: | . | (json) the current local credentials as a json | . Example: . client.local_auth({type: &quot;basic&quot;, user: &quot;admin&quot;, key: &quot;root&quot; }) . remote auth . client.remote_auth(credentials) . Description: Gets / sets the credentials for connecting to a remote TerminusDB server for push / pull / clone / fetch operations . Status: Stable . Arguments: . credentials: (json - optional) the credentials to use to authenticate to the remote TerminusDB server type: (string - mandatory) either “jwt” or “basic” | key: (string - mandatory) either the jwt token or the basic auth password depending on the type field | user: (string - optional) the user id to use for basic authentication - defaults to “admin” Returns: | . | (json) the current remote credentials as a json | . Example: . client.local_auth({type: &quot;jwt&quot;, key: &quot;....&quot;}) . databases . client.databases() . Description: retrieves a list of databases (id, organization, label, comment) that the current user has access to on the server. Note that this requires the client to call connect() first. . Status: Stable . Arguments: None . Returns: . (Array(json)) a list of databases the user has access to on the server, each having: id: (string) the id of the database | organization: (string) the id of the organization the database belongs to | label: (string) the display name of the database | comment: (string) the description text for the database | . | . Example: . let my_dbs = client.databases() . get database . client.get_database(dbid, orgid) . Description: Retrieves metadata (label, comment) about a particular database. . Status: Stable . Arguments: . dbid (string - mandatory) the id of the database | orgid (string - optional) the id of the organization to which the database belongs (defaults to ‘admin’) | . Returns: . (json) a json with fields representing metadata about the db: id: (string) the id of the database | organization: (string) the id of the organization the database belongs to | label: (string) the display name of the database | comment: (string) the description text for the database | . | . Example: . let my_db = client.get_database() . author . client.author(author_id) . Description: Gets / sets the string that will be written into the commit log for the current user . Status: Stable . Arguments: . author_id (string - optional) the id to write into commit logs as the author string (normally an email address) | . Returns: . (string) the current author id in use for the current user | . Example: . client.author(&quot;my@myemail.com&quot;) . set system db . client.set_system_db() . Description: sets the internal client context to allow it to talk to the server’s internal system database . Status: Stable . Arguments: None . Returns: None . Example: . client.set_system_db() . set . client.set(opts) . Description: sets several of the internal state values in a single call (similar to connect, but only sets internal client state, does not communicate with server) . Status: Stable . Arguments: (json - mandatory) opts - a json object with the following optional fields: . organization: (string) the id of the organization to connect to (in desktop use, this will always be “admin”) | db: (string) the id of the database to connect to | local_auth: (json) a local auth configuration used to authenticate the client to the local server | key: (string) basic auth password | user: (string) basic auth username (always admin in desktop mode) | remote_auth: (json) a remote auth configuration - passed to the server to authenticate itself to remote servers during pull / push / clone / fork / fetch | branch: (string) id of branch to connect to (defaults to main) | ref: (string) id of the commit to connect to (defaults to head) | repo: (string) id of the repository to connect to (defaults to local) | . Returns: None . Example: . client.set({key: &quot;mypass&quot;, branch: &quot;dev&quot;, repo: &quot;origin&quot;}) . Utility Functions . copy . client.copy() . Description: creates a copy of the client with identical internal state and context - useful if we want to change context for a particular API call without changing the current client context . Status: Stable . Arguments: None . Returns: . (WOQLClient) new client object with identical state to original but which can be manipulated independently | . Example: . let tempClient = client.copy() . resource . client.resource(type, val) . Description: generates a resource string for the required context . Arguments: . type (string - mandatory) the type of resource string that is required - one of “db”, “meta”, “repo”, “commits”, “branch”, “ref” | val (string - optional) - can be used to specify a specific branch / ref - if not supplied the current context will be used | . Returns: . (string) - a resource string for the desired context | . Example: . let branch_resource = client.resource(&quot;branch&quot;) .",
    "url": "/docs/reference/js-client/core/",
    "relUrl": "/reference/js-client/core/"
  }
  ,"12": {
    "title": "Importing and Cleaning Data From CSVs",
    "content": "Importing and Cleaning Data from CSVs . In this tutorial, we will learn how to load data from a CSV file then clean it up with some data wrangling, like changing the type of the data, combining strings and generating ids for objects. . Jump to . TOC | . Step 1 - reading the CSV columns . In our example, we will try to load data from this CSV: https://terminusdb.com/t/data/bike_tutorial.csv . This can be done by making woql queries. In this tutorial, we will be making queries in the TerminusDB console. However, you can also do it with TerminusDB clients. . To make a query in the console, go to the query tab by clicking on query at the top. . . Now it’s time for the query. Our first step is to load in each column as a woql variable. This can be done with the following script: . WOQL.get( WOQL.as(&quot;Start station&quot;,&quot;v:Start_Station&quot;) .as(&quot;End station&quot;, &quot;v:End_Station&quot;) .as(&quot;Start date&quot;, &quot;v:Start_Time&quot;) .as(&quot;End date&quot;, &quot;v:End_Time&quot;) .as(&quot;Duration&quot;, &quot;v:Duration&quot;) .as(&quot;Start station number&quot;, &quot;v:Start_ID&quot;) .as(&quot;End station number&quot;, &quot;v:End_ID&quot;) .as(&quot;Bike number&quot;, &quot;v:Bike&quot;) .as(&quot;Member type&quot;, &quot;v:Member_Type&quot;) ).remote(&quot;https://terminusdb.com/t/data/bike_tutorial.csv&quot;) . This script involves get, as and remote method. For more explanation about these methods, please see their reference in woql. . This is loading a remote CSV from the link. For loading a local file, please see the reference of file method. . If you click run query now, you will see the CSV is imported and the result is shown in a tabular format. . . You can switch back to the Query tab by clicking on Query next to Result Viewer on top of the results. . However, the data read in this step is not updated in any graphs. To save the data in the graph, we will assign this query to a variable and combine it with the following steps. . const csv = WOQL.get( WOQL.as(&quot;Start station&quot;,&quot;v:Start_Station&quot;) .as(&quot;End station&quot;, &quot;v:End_Station&quot;) .as(&quot;Start date&quot;, &quot;v:Start_Time&quot;) .as(&quot;End date&quot;, &quot;v:End_Time&quot;) .as(&quot;Duration&quot;, &quot;v:Duration&quot;) .as(&quot;Start station number&quot;, &quot;v:Start_ID&quot;) .as(&quot;End station number&quot;, &quot;v:End_ID&quot;) .as(&quot;Bike number&quot;, &quot;v:Bike&quot;) .as(&quot;Member type&quot;, &quot;v:Member_Type&quot;) ).remote(&quot;https://terminusdb.com/t/data/bike_tutorial.csv&quot;) . Step 2 - data wrangling . In the next step, we are going to prepare the data for step 3. The data that we got in step 1 is not ready to be put in the graph. We will have to generate an id for doctype objects, convert data to their correct data types and create strings for labels and descriptions. . To do that, we will expand our previous script as follows: . const csv = WOQL.get( WOQL.as(&quot;Start station&quot;,&quot;v:Start_Station&quot;) .as(&quot;End station&quot;, &quot;v:End_Station&quot;) .as(&quot;Start date&quot;, &quot;v:Start_Time&quot;) .as(&quot;End date&quot;, &quot;v:End_Time&quot;) .as(&quot;Duration&quot;, &quot;v:Duration&quot;) .as(&quot;Start station number&quot;, &quot;v:Start_ID&quot;) .as(&quot;End station number&quot;, &quot;v:End_ID&quot;) .as(&quot;Bike number&quot;, &quot;v:Bike&quot;) .as(&quot;Member type&quot;, &quot;v:Member_Type&quot;) ).remote(&quot;https://terminusdb.com/t/data/bike_tutorial.csv&quot;) //Transform data into correct shape for insert const wrangles = [ WOQL.typecast(&quot;v:Duration&quot;, &quot;xsd:integer&quot;, &quot;v:Duration_Cast&quot;), WOQL.typecast(&quot;v:Bike&quot;, &quot;xsd:string&quot;, &quot;v:Bike_Label&quot;), WOQL.typecast(&quot;v:Start_Time&quot;, &quot;xsd:dateTime&quot;, &quot;v:ST_Cast&quot;), WOQL.typecast(&quot;v:End_Time&quot;, &quot;xsd:dateTime&quot;, &quot;v:ET_Cast&quot;), WOQL.typecast(&quot;v:Start_Station&quot;, &quot;xsd:string&quot;, &quot;v:SS_Label&quot;), WOQL.typecast(&quot;v:End_Station&quot;, &quot;xsd:string&quot;, &quot;v:ES_Label&quot;), WOQL.idgen(&quot;doc:Journey&quot;,[&quot;v:Start_ID&quot;,&quot;v:Start_Time&quot;,&quot;v:Bike&quot;],&quot;v:Journey_ID&quot;), WOQL.idgen(&quot;doc:Station&quot;,[&quot;v:Start_ID&quot;],&quot;v:Start_Station_URL&quot;), WOQL.idgen(&quot;doc:Station&quot;,[&quot;v:End_ID&quot;],&quot;v:End_Station_URL&quot;), WOQL.idgen(&quot;doc:Bicycle&quot;,[&quot;v:Bike_Label&quot;],&quot;v:Bike_URL&quot;), WOQL.concat(&quot;v:Start_ID - v:End_ID @ v:Start_Time&quot;,&quot;v:J_Label&quot;), WOQL.concat(&quot;Bike v:Bike from v:Start_Station to v:End_Station at v:Start_Time until v:End_Time&quot;,&quot;v:Journey_Description&quot;) ]; //Combine with logical and WOQL.and(csv, ...wrangles) . For explanations about the idgen, typecast and concat methods that are used in the data wrangling, please see their reference in woql. . If you click run query now, you will see that we have got new variables that have been created with the data wrangling. However, the data is not loaded in the graph yet. . . Step 3 - insert data . For the last step, we will insert the data that we prepared into the graph. The whole script that includes this step and the previous steps is here: . const csv = WOQL.get( WOQL.as(&quot;Start station&quot;,&quot;v:Start_Station&quot;) .as(&quot;End station&quot;, &quot;v:End_Station&quot;) .as(&quot;Start date&quot;, &quot;v:Start_Time&quot;) .as(&quot;End date&quot;, &quot;v:End_Time&quot;) .as(&quot;Duration&quot;, &quot;v:Duration&quot;) .as(&quot;Start station number&quot;, &quot;v:Start_ID&quot;) .as(&quot;End station number&quot;, &quot;v:End_ID&quot;) .as(&quot;Bike number&quot;, &quot;v:Bike&quot;) .as(&quot;Member type&quot;, &quot;v:Member_Type&quot;) ).remote(&quot;https://terminusdb.com/t/data/bike_tutorial.csv&quot;) //Clean data for insert const wrangles = [ WOQL.typecast(&quot;v:Duration&quot;, &quot;xsd:integer&quot;, &quot;v:Duration_Cast&quot;), WOQL.typecast(&quot;v:Bike&quot;, &quot;xsd:string&quot;, &quot;v:Bike_Label&quot;), WOQL.typecast(&quot;v:Start_Time&quot;, &quot;xsd:dateTime&quot;, &quot;v:ST_Cast&quot;), WOQL.typecast(&quot;v:End_Time&quot;, &quot;xsd:dateTime&quot;, &quot;v:ET_Cast&quot;), WOQL.typecast(&quot;v:Start_Station&quot;, &quot;xsd:string&quot;, &quot;v:SS_Label&quot;), WOQL.typecast(&quot;v:End_Station&quot;, &quot;xsd:string&quot;, &quot;v:ES_Label&quot;), WOQL.idgen(&quot;doc:Journey&quot;,[&quot;v:Start_ID&quot;,&quot;v:Start_Time&quot;,&quot;v:Bike&quot;],&quot;v:Journey_ID&quot;), WOQL.idgen(&quot;doc:Station&quot;,[&quot;v:Start_ID&quot;],&quot;v:Start_Station_URL&quot;), WOQL.idgen(&quot;doc:Station&quot;,[&quot;v:End_ID&quot;],&quot;v:End_Station_URL&quot;), WOQL.idgen(&quot;doc:Bicycle&quot;,[&quot;v:Bike_Label&quot;],&quot;v:Bike_URL&quot;), WOQL.concat(&quot;v:Start_ID - v:End_ID @ v:Start_Time&quot;,&quot;v:J_Label&quot;), WOQL.concat(&quot;Bike v:Bike from v:Start_Station to v:End_Station at v:Start_Time until v:End_Time&quot;,&quot;v:Journey_Description&quot;) ]; //combine inputs const inputs = WOQL.and(csv, ...wrangles) //generate data to be inserted const inserts = WOQL.and( WOQL.insert(&quot;v:Journey_ID&quot;, &quot;Journey&quot;) .label(&quot;v:J_Label&quot;) .description(&quot;v:Journey_Description&quot;) .property(&quot;start_time&quot;, &quot;v:ST_Cast&quot;) .property(&quot;end_time&quot;, &quot;v:ET_Cast&quot;) .property(&quot;duration&quot;, &quot;v:Duration_Cast&quot;) .property(&quot;start_station&quot;, &quot;v:Start_Station_URL&quot;) .property(&quot;end_station&quot;, &quot;v:End_Station_URL&quot;) .property(&quot;journey_bicycle&quot;, &quot;v:Bike_URL&quot;), WOQL.insert(&quot;v:Start_Station_URL&quot;, &quot;Station&quot;) .label(&quot;v:SS_Label&quot;), WOQL.insert(&quot;v:End_Station_URL&quot;, &quot;Station&quot;) .label(&quot;v:ES_Label&quot;), WOQL.insert(&quot;v:Bike_URL&quot;, &quot;Bicycle&quot;) .label(&quot;v:Bike_Label&quot;) ); //Combine inputs and inserts with when clause WOQL.and(inputs, inserts); . For details about how insert works, please refer to the woql reference. . As this time we are updating the graph, we can put in a commit message (e.g. Insert data form CSV) in the box above the query which says “Enter reason for update here” before we hit run query. If there’s no commit message given, a default message will be used as a commit message. . . After clicking run query, you will now see the message in the green box saying “Successfully updated database”. . . Now you can check that the data has been added by clicking on Documents at the top. . .",
    "url": "/docs/tutorials/csv-tutorial/",
    "relUrl": "/tutorials/csv-tutorial/"
  }
  ,"13": {
    "title": "Data Modeling",
    "content": "Data Modeling . TerminusDB Graph Basics . TerminusDB organizes data in a very simple structure to make it easy and natural to model the real world. . Whereas traditional relational databases divide data into tables, columns and rows, in TerminusDB everything is an object - objects can have properties and some of these properties may link to other objects. The network of interlinked objects forms a graph structure (in the mathematical sense - nodes and edges). . This is the basic idea of the graph database - using data structures that are things rather than cells allows users to create models that are much closer to the real world things that they want to model - because people perceive the world as things, not cells. . To explain with a very simple example - if we were building a database to hold a family tree and we wanted to record the parents and grandparents of an individual. In a relational database, we might record this in a simple table . . In a graph database, this would look like the following . . The big advantage is that it is much easier to interpret the model and understand how it maps to real world entities compared to the relational example. This increased ease also extends to querying the database. . Query . For example, if we wanted to fetch the name of john’s mother and grandmother from the database, if we were using a relational database, we could use the following two SQL queries to get the name of the mother and grandmother respectively: . SELECT Name from TABLE where Person_ID = (SELECT mother from TABLE where Name=&quot;John&quot;) SELECT Name from TABLE where Person_ID = (SELECT mother from TABLE WHERE Person_ID = (SELECT mother from TABLE where Name=&quot;John&quot;)) . In a graph database this is much simpler: we can use a triple pattern such as the following to get both names in the same query - we do not have to explicitly join the records together, the joins are implicit - we use the same ID in different parts of the query: . WOQL.and( WOQL.triple(&quot;v:Person&quot;, &quot;mother&quot;, &quot;v:MotherID&quot;), WOQL.triple(&quot;v:MotherID&quot;, &quot;name&quot;, &quot;v:MotherName&quot;), WOQL.triple(&quot;v:MotherID&quot;, &quot;mother&quot;, &quot;v:GrandmotherID&quot;), WOQL.triple(&quot;v:GrandmotherID&quot;, &quot;name&quot;, &quot;v:GrandmotherName&quot;), ) . By using “v:MotherID” multiple times in the query, we create a chain: v:Person =mother=&gt; v:Mother =mother=&gt; v:Grandmother . This makes our queries much easier to understand - we can follow them naturally across multiple patterns. . Classes &amp; Properties . Under the hood, TerminusDB uses a very rich data modelling language called OWL - the Web Ontology Language. Although it is a very rich language, the basic ideas are simple. . In our schema, we can define classes - which are definitions of types of complex data structure. Classes can be subclasses of other classes, which means that they inherit all the parent’s definitions (much like inheritance in object-oriented programming). We can also define properties in the schema - each property has a domain (the class that is the subject of the property) and a range - the type of data that the property points to. The range can either be a simple datatype literal (e.g. an integer or string) or it can be a class. . For most use cases, that’s all you really need to know. You define a hierarchy of classes to represent the different types of things that you want to represent in your database, then you define properties to represent the different attributes of these things that you want to record and the relationships between the things. From these simple building blocks - class hierarchies and typed properties, you can build almost arbitrarily complex data structures to represent whatever real world entities you are interested in. . Here are some posts: . Data Modeling: Painting Pictures in the Medium of Pure Abstraction . . | Anatomy of a Knowledge Graph . |",
    "url": "/docs/discussion/data-model/",
    "relUrl": "/discussion/data-model/"
  }
  ,"14": {
    "title": "FAQs",
    "content": ". Frequently Asked Questions . (Ask a question enough times and it will appear here) . What is TerminusDB? . What is TerminusHub? . Wait… what? You can just pass complex and queryable databases around the web for free? . Why is TerminusDB useful? . When should I use TerminusDB? . What is the underlying TerminusDB architecture? . TerminusDB is open source and TerminusHub is free to use, what do you sell? . Can I get a commercial license for TerminusDB? . How is data stored in TerminusDB? . As a dev or a data scientist, how do I work with TerminusDB? . Is TerminusDB ACID? . How does TerminusDB scale? . What’s up with the CowDuck? . How is TerminusDB different from relational databases like Oracle? . What is the history of the project? . Why did you write your own database? . Why do you use WOQL - web object query language? . And why not SPARQL or Cypher? . Why JSON-LD? . Why Prolog and Rust? . What’s the performance like? Do you have any benchmarks? . Can TerminusDB be used for big datasets? . Do I have to register anywhere to use TerminusDB? . Why not just use another well-known graph DB or data versioning tool? . Can I use TerminusDB as a document store? . . What is TerminusDB? . TerminusDB is an open-source general-purpose graph database that stores data like Git. It is built for data people and allows fierce data integration, versioning out of the box, and unparalleled query. No data platform is more productive. . Download center . . What is TerminusHub? . TerminusDBs are linked through TerminusHub. The hub allows the user to manage access to databases and to collaboratively work on shared resources. You can make changes to a database, push them to hub and have a collaborator pull the synced version of the database. . You can share and collaborate on curated datasets in a distributed manner using git-like operations (push, pull, fetch, clone, fork). . Data Catalogs can be easily built on top of curated datasets giving verified information about contents and allowing discovery both inside the organization, and outside using TerminusHub . Collaboration is easy with the clone/fork operation, allowing data to be moved to your cloud or servers. Merge and branch operations let you mix and match data sources, significantly simplifying integration tasks . More information and sign up . . Wait… what? You can just pass complex and queryable databases around the web for free? . Yes, you can. Distributed revision control for structured data is here. . . Why is TerminusDB useful? . TerminusDB is built around three core design principles that collectively enable you to build faster, and with higher quality: . Fierce git-like collaborative data integration. Merge and branch operations let you mix and match data sources. | Revision Control enables collaboration, so you can work on different versions of the same asset at the same time in a controlled way without risk of data loss. | TerminusDB is a powerful graph database and analytic engine. It is built around relationships that power core data and software products. In today’s world, relationships among data ARE the data and they do not typically fit in rows and columns. | TerminusDB is the only database which enables and supplies all of these operations. . . When should I use TerminusDB? . TerminusDB and TerminusHub can be used across a range of OLTP and analytical apps. . TerminusDB Server provides TerminusDB with a RESTful API for interacting with knowledge graphs via the JSON-LD exchange format. This means you can easily compose applications within your own toolchain which utilize the powerful features of graph search and graph storage. . We think TerminusDB is perfect for OLTP use cases with transactions in the tens of thousands per day, such as headless-CMS, data curation, inventory management etc. . . What is the underlying TerminusDB architecture? . We use an advanced git-like model, storing append-only changes to graphs represented in succinct data structures using terminusdb-store. . You can read a description of the architecture in our Succinct Data Structures and Delta Encoding for Modern Databases whitepaper. . . TerminusDB is open source and TerminusHub is free to use, what do you sell? . TerminusDB will be fully featured and open source (GPLv3) forever. TerminusHub has a freemium tier and paid subscriptions for private collaboration. We borrowed the GitHub commercial model. . More information on pricing and subscriptions here. . If you are working with an open-source or public interest project, we want you to be free forever, so send us a message. . . Can I get a commercial license for TerminusDB? . We have support for TerminusDB and enterprise licenses for TerminusHub. Get in touch. . . How is data stored in TerminusDB? . TerminusDB Store is an RDF triple store implemented in Rust. . . As a dev or a data scientist, how do I work with TerminusDB? . To accelerate your productivity, TerminusDB has developed SDKs for Python and JavaScript (we are planning more so let us know what should be next). All supported SDKs are designed to be idiomatic for the given programming language (designing a Pythonic query language). This makes it much more natural for developers to work with data than string-based languages like SQL, and eliminates the need for cumbersome and fragile ORM abstraction layers. . You can also interact with TerminusDB and Hub graphically using our console, the GUI for TerminusDB. You can explore and manipulate your data, visually create queries, create and manage branches and much more. . . Is TerminusDB ACID? . Yes. . . How does TerminusDB scale? . TerminusDB primarily scales vertically. It uses succinct data structures’ advantage of ever-increasing main memory available in modern machines, to get very large graphs in-memory. . Graph partitioning is used to scale beyond a single machine. . . What’s up with the CowDuck? . When our core storage engineer first presented the shiny new storage engine, he used an example of a cow that liked a duck, but the duck didn’t like the cow. From that, and a subsequent internal debate, CowDuck was born! There is still some evidence of the original cow and duck on the TerminusDB Store GitHub page. . . How is TerminusDB different from relational databases like Oracle? . Relational databases like Oracle, MySQL, SQL Server, Postgres and others are built on architectures originally designed over 40 years ago. The requirements for applications were very different back in the 1970s. Codd’s innovations were indeed a benefit, as they brought schemas to a wild west. The problem is that they are unnecessarily restrictive and poor at data modeling. In data modeling, inheritance, multiple inheritance, and object identity are big advantages with complex data science and ML/AI projects or application. . RDBMSs are simply too primitive and not built with the developer or the data engineer/scientist in mind. . . What is the history of the project? . We are originally a University spin-out. There is a great blog on the technical history. . . Why did you write your own database? . We started off by testing and building on other databases but constantly faced performance issues. By building all the way down to the ground, we could deliver a native revision control database. . Some solutions are just a version control layer on a traditional (usually relational) database; however, piecemeal additions without a fundamentally append-only, immutable store often cause more problems than they solve. We think that a native approach makes the most sense and will ultimately deliver the most value. . . Why do you use WOQL - web object query language? . The user interacts with TerminusDB through our JavaScript and Python SDKs. We hope to extend the number of SDKs over time. . WOQL is a powerful, highly expressive and composable graph query language. In its fluent form, WOQL is human-readable and easy to understand. It allows recursive queries and manipulation of paths through the graph. . WOQL is easy to compose from JavaScript or Python. JavaScript, because we live in a web age, and Python, because it is the choice for many data scientists. JSON-LD provides a nice intermediate language in which to write queries in either of these languages. Because of the choice of JSON-LD, we can naturally store our queries in the graph (and even query our queries). . . And why not SPARQL or Cypher? . We debated using SPARQL initially; however, we found SPARQL to have a number of shortcomings that we wanted to see addressed. We wanted tighter integration with OWL and schema-awareness, so if we were going to need to fundamentally alter the semantics, it didn’t seem that important to start with SPARQL. We wanted better composability and SPARQL feels quite ad-hoc. . We also assessed Cypher and found that it lacked some of the features we needed. It is also primarily geared towards property graphs and not RDF graphs. It also does not enable the smooth SDK manipulation that WOQL facilitates by using JSON-LD as a query interchange format. . We think that the Python and Javascript SDKs for TerminusDB are the main way that users will interact with the database. . . Why JSON-LD? . Using JSON-LD as the definition, storage and interchange format for the query language has advantages. Since we can marshal JSON-LD into and out of the graph, it is easy to store queries in the graph. It is also simple to write query libraries for a range of languages by just building up a JSON-LD object and sending it off. . . Why Prolog and Rust? . Prolog is the language of AI. It is powerful and geared towards logic and reason. It is perfect for querying, constraint checking, query compilation, query analysis and user interaction. However, it is not good at nitty-gritty bit manipulation – that is where Rust comes in! It is low-level like C/C++, but memory-safe. . . What’s the performance like? Do you have any benchmarks? . We started with a graph simulation in PostgreSQL and found it to be too slow for our purposes. We settled on or current data-structures after satisfying ourselves that it was much faster for deep multi-hop queries. We are developing benchmarks and doing lots of work on performance. Watch this space – or get involved and put the DB to the test. . . Can TerminusDB be used for big datasets? . Yes. TerminusDB is optimized to work with big datasets on the scale of tens of millions to billions of graph edges. . . Do I have to register anywhere to use TerminusDB? . No, you can use the open-source TerminusDB without registering or doing anything else. . If you want to use TerminusHub, we need an email address as a signature to put into the commit-graph, so you’ll have to register. . Sign up here! . . Why not just use another well-known graph DB or data versioning tool? . Here is a blog discussing just that point! . . Can I use TerminusDB as a document store? . Yes, but to do so you need to first define the schema which defines a document. TerminusDB is a graph so it needs to know how you mean to store your documents as a graph. The advantage, however, is that you’ll be able to search any property or value of your documents .",
    "url": "/docs/frequently-asked-questions/",
    "relUrl": "/frequently-asked-questions/"
  }
  ,"15": {
    "title": "Import and Clean Data in Python",
    "content": "Import and Clean Data . . CSV | Turtle / RDF | Larger TTLs Medium Data Sets | Larger Data Sets | | . CSV . In order to load data from CSV you need to map each column of interest to a variable, and then insert triples with the data you are interested in. If you have a database without a schema then you can simply import the data on properties which are named appropriately. . If we take the following roster.csv CSV for instance: . Name,Registration_Date,Paid George,2017-01-02,Yes Willie,2017-01-02,No . We can load this into a graph as follows: . #!/usr/bin/python3 from terminusdb_client import WOQLClient from terminusdb_client import WOQLQuery as WQ server_url = &quot;https://127.0.0.1:6363&quot; user = &quot;admin&quot; account = &quot;admin&quot; key = &quot;root&quot; db = &quot;roster&quot; repository = &quot;local&quot; label = &quot;Roster CSV Example&quot; description = &quot;An example database for playing with bank accounts&quot; client = WOQLClient(server_url) client.connect(user=user, account=account, key=key, db=db) #client.delete_database(db) try: client.create_database(db,account,label=label, description=description, include_schema=None) except Exception as E: pass query = WQ().woql_and( WQ().get(WQ().woql_as(&quot;Name&quot;,&quot;v:Name&quot;) .woql_as(&quot;Registration_Date&quot;, &quot;v:Date&quot;) .woql_as(&quot;Paid&quot;, &quot;v:Paid&quot;) ).post(&#39;roster.csv&#39;), WQ().idgen(&quot;doc:RosterRecord&quot;,[&quot;v:Name&quot;,&quot;v:Date&quot;,&quot;v:Paid&quot;],&quot;v:ID&quot;), WQ().add_triple(&quot;v:ID&quot;,&quot;scm:name&quot;,&quot;v:Name&quot;), WQ().add_triple(&quot;v:ID&quot;,&quot;scm:date&quot;,&quot;v:Date&quot;), WQ().add_triple(&quot;v:ID&quot;,&quot;scm:paid&quot;,&quot;v:Paid&quot;)) client.query(query, &quot;Adding Roster Data&quot;, {&#39;roster.csv&#39; : &#39;/home/gavin/tmp/roster.csv&#39;} ) . The get loads our csv from a post variable roster.csv. We will pass the path for this to the client when we execute the query. . We can also load a URL which contains the csv using instead the remote keyword. . The first argument of the woql_as is the column header name, the second is the name of the variable which will carry this data. . We want to construct an URI identifier which carries a unique representation of the record from the roster. We can do this with idgen which will create a valid id from the key for us. . The final add_triple simply adds the information for this property to the database. . Turtle / RDF . For RDF ingestion TerminusDB can read directly from a TTL file with get, as above, if you supply the type flag. If you don’t have a TTL file, you should use on of the abundant RDF tools from transforming RDF into TTL. . #!/usr/bin/python3 from terminusdb_client import WOQLClient from terminusdb_client import WOQLQuery as WQ server_url = &quot;https://127.0.0.1:6363&quot; db = &quot;api&quot; label = &quot;API&quot; description=&quot;The API Ontology&quot; user = &quot;admin&quot; account = &quot;admin&quot; key = &quot;root&quot; client = WOQLClient(server_url) client.connect(user=user, account=account, key=key, db=db) try: client.create_database(db,account,label=label, description=description, include_schema=None) except Exception as E: print(E) [x,y,z] = WQ().vars(&quot;x&quot;,&quot;y&quot;,&quot;z&quot;) query = WQ().get( WQ().woql_as(x).woql_as(y).woql_as(z) ).post(&quot;api.owl.ttl&quot;, {&quot;type&quot; : &quot;turtle&quot;}) client.query(query, &quot;Adding turtle file contents&quot;, {&quot;api.owl.ttl&quot; : &quot;/home/me/tmp/api.owl.ttl&quot;) . This will load the turtle file designated as &quot;/home/me/tmp/api.owl.ttl&quot; into the current database. . Larger TTLs . The above method is best used if you want to load small files or transform the data, or mix and match with other import files during import. . However, if you’re just trying to load a large number of triples, it is better to use the triples client interface. . Medium Data Sets . If you have fewer than 500k triples (perhaps called my_triples.ttl) you can load it as follows: . #!/usr/bin/python3 from terminusdb_client import WOQLClient from terminusdb_client import WOQLQuery as WQ server_url = &quot;https://127.0.0.1:6363&quot; db = &quot;my_triples&quot; label = &quot;My Triples&quot; description=&quot;My Triples&quot; user = &quot;admin&quot; account = &quot;admin&quot; key = &quot;root&quot; filename = &quot;my_triples.ttl&quot; client = WOQLClient(server_url) client.connect(user=user, account=account, key=key, db=db) try: client.create_database(db,account,label=label, description=description, include_schema=None) except Exception as E: print(E) ttl_file = open(filename) contents = ttl_file.read() ttl_file.close() client.insert_triples( &quot;instance&quot;,&quot;main&quot;, contents, f&quot;Adding my triples&quot;) . Larger Data Sets . If you have a rather large file (&gt;500k triples) you should process it by chunking it. . For example, if we want to load the Person) data, we can process it as follows: . First, we download this file and unpack it. Since the dataset is large, we will move the ttl into a folder and split it into chunks. . From linux on the command line this can be achieved with a programme like split. . split -l 100000 persons.ttl . If we put these files into a subfolder named ‘persons_100k’ we can then iterate over them and insert them as follows: . import os import time from terminusdb_client import WOQLClient from terminusdb_client import WOQLQuery as WQ server_url = &quot;https://127.0.0.1:6363&quot; db = &quot;person&quot; db_label = &quot;Persons&quot; db_comment = &quot;A Database of People&quot; directory = &#39;persons_100k&#39; user = &quot;admin&quot; account = &quot;admin&quot; key = &quot;root&quot; client = WOQLClient(server_url) client.connect(user=user, account=account, key=key, db=db) try: client.delete_database(db) except Exception as E: print(E) client.create_database(db,account,label=f&quot;{db_label}&quot;, include_schema=False, description=f&quot;All DBPedia {db} data&quot;) times = [] for f in os.listdir(directory): filename = f&#39;{directory}/{f}&#39; ttl_file = open(filename) contents = ttl_file.read() ttl_file.close() before = time.time() client.insert_triples( &quot;instance&quot;,&quot;main&quot;, contents, f&quot;Adding persondata in 100k chunk ({f})&quot;) after = time.time() total = (after - before) times.append(total) print(f&quot;Update took {total} seconds&quot;) print(times) . The heavy lifting here is again done by client.insert_triples. . You should be able to load files in excess of 30 million triples this way. .",
    "url": "/docs/how-tos/python/import-data-python/",
    "relUrl": "/how-tos/python/import-data-python/"
  }
  ,"16": {
    "title": "Import and Clean CSV Data",
    "content": "Import and Clean Data . . CSV Loading CSVs from files and URLs Loading CSV From a URL | Loading CSV From a file | | Mapping Columns to Variables Mapping Columns by Name (Column Header) | Mapping Columns by Number | CSVs without headers | | Maninpulating CSV data | Typecasting | Type mapping | Combining data from multiple columns | Extracting Data From Columns with regular expressions | Inserting Data From CSVs Generating IDs | Writing Data | | | . CSV . CSV files can be loaded directly into TerminusDB either from a URL or from a file on your local server using the get() operation. . Loading CSVs from files and URLs . Loading CSV From a URL . get(....).remote(&quot;http://seshatdatabank.info/wp-content/uploads/2020/01/Iron-Updated.csv&quot;) . Loading CSV From a file . get(....).file(&quot;/app/local_files/Iron-Updated.csv&quot;) . Mapping Columns to Variables . In order to address data in the CSV you need to map each column of interest in the CSV to a TerminusDB variable using the as() operation . There are two different ways in which we can map CSV columns - by column header or by column number . If we take the following roster.csv CSV for instance: . Name,Registration_Date,Paid George,2017-01-02,Yes Willie,2017-01-02,No . Mapping Columns by Name (Column Header) . We can map the 3 colums in the CSV to TerminusDB Variables, by using the column header text : . get(as(&quot;Name&quot;,&quot;v:Name&quot;) .as(&quot;Date&quot;, &quot;v:Date&quot;) .as(&quot;Paid&quot;, &quot;v:Paid&quot;)).file(&#39;/app/local_files/roster.csv&#39;) . The first argument of the as is the column header name, the second is the name of the TerminusDB variable which will be populated with the data in the column. . We do not need to map all columns, only those we are interested in. So, for example, if we are only interested in the Date and Name fields, we can write: . get(as(&quot;Name&quot;,&quot;v:Name&quot;) .as(&quot;Date&quot;, &quot;v:Date&quot;)).file(&#39;/app/local_files/roster.csv&#39;) . Mapping Columns by Number . The second form of the as operator allows us to map columns by column number (indexed from 0). For example, the equivalent of the 3 column import from above would be: . get(as(0, &quot;v:Name&quot;) .as(1, &quot;v:Date&quot;) .as(2, &quot;v:Paid)).file(&#39;/app/local_files/roster.csv&#39;) . This will map the first 3 columns to the same 3 variables - having exactly the same effect as the above example . CSVs without headers . By default, TerminusDB assumes that the first line of a CSV contains headers for the columns. In some cases we may just have data, with no column headers. To deal with this situation, we set format_header to be false in the file or remote operation . get(...).remote(&quot;http://seshatdatabank.info/wp-content/uploads/2020/01/Iron-Updated.csv&quot;, {format_header: false}) get(...).file(&#39;/app/local_files/roster.csv&#39;, {format_header: false}) . The first line will be interpreted as data, not headers, and the columns can be mapped to variables by number . Maninpulating CSV data . Once CSV data has been mapped to TerminusDB variables, they can be used in queries just like native variables: . and( get(as(&quot;Name&quot;,&quot;v:Name&quot;) .as(&quot;Date&quot;, &quot;v:Date&quot;) .as(&quot;Paid&quot;, &quot;v:Paid&quot;)).file(&#39;/app/local_files/roster.csv&#39;), triple(&quot;v:EntryID&quot;, &quot;scm:name&quot;, &quot;v:Name&quot;) ) . This will find all entries in the exiting database which have the same name (scm:name) as the variable (v:Name) which contains the imported data from the CSV . Typecasting . Every CSV datapoint is imported by default as a string. It is often useful to cast these strings to a better type to represent it. So, for example, in the above example, we probably want to treat “v:Date” as an actual date. The typecast() operation can be applied to imported CSV variables to make them treated as if they were another type than a string: . and( get(as(&quot;Name&quot;,&quot;v:Name&quot;) .as(&quot;Date&quot;, &quot;v:Date&quot;) .as(&quot;Paid&quot;, &quot;v:Paid&quot;)).file(&#39;/app/local_files/roster.csv&#39;), typecast(&quot;v:Date&quot;, &quot;xsd:date&quot;, &quot;v:RealDate&quot;) .less(&quot;v:RealDate&quot;, &quot;2010-01-01&quot;) ) . The above example will cause the date comparison operator to work correctly because the “v:RealDate” variable has been typecast to the correct type. . Type mapping . In cases where there are no automatic typecasting operation available, we can still manually manipulate the CSV data to map it to the correct type: . and( get(as(&quot;Name&quot;,&quot;v:Name&quot;) .as(&quot;Date&quot;, &quot;v:Date&quot;) .as(&quot;Paid&quot;, &quot;v:Paid&quot;)).file(&#39;/app/local_files/roster.csv&#39;), eq(&quot;v:Paid&quot;, &quot;Yes&quot;).eq(&quot;v:PaidBoolean&quot;, literal(true, &quot;boolean&quot;)) eq(&quot;v:Paid&quot;, &quot;No&quot;).eq(&quot;v:PaidBoolean&quot;, literal(false, &quot;boolean&quot;)) ) . In the above case we have constructed a new variable of the desired type (v:PaidBoolean) and mapped Yes to true and No to false, creating the boolean variable that we want. . Combining data from multiple columns . It is often the case that we want to combine data from multiple columns into a single variable. For example, consider the following CSV example: . First Name,Last Name George,Smith Willie,Nelson . If we want to combine the two CSV column into a single variable to represent the full name of the individuals, we can do so as follows: . and( get( as(&quot;First Name&quot;,&quot;v:First&quot;) .as(&quot;Last Name&quot;, &quot;v:Last&quot;) ).file(&#39;/app/local_files/roster.csv&#39;), concat(&quot;v:First v:Last&quot;, &quot;v:Full&quot;) ) . In the above example the variable “v:Full” will have the full name, assembled from the first name and last name with a space in between. . Extracting Data From Columns with regular expressions . Sometimes, the data in the CSV needs to be significantly transformed from the input format. For example, we might want to extract patterns from multiple columns, or extract a substring from a particular column. In such cases regular expressions provide a great degree of flexibility in extracting the precise information that we want. For example, if we have a CSV with the following structure: . Full Name,Date of Birth George Smith, 08/10/1970 Willie Nelson, 09/05/1963 . In this example, if we wish to extract the first name and last name to independent variables, a regular expression does the trick: . javascript and( get( as(“Full Name”,”v:Full”) ).file(‘/app/local_files/roster.csv’), re(“ [^ ]$”, “v:Full Name”, [“v:Last Name”, “v:All”]), re(“$[^ ]$”, “v:Full Name”, [“v:First Name”, “v:All”]) ) . …. . Inserting Data From CSVs . Generating IDs . We want to construct an URI identifier which carries a unique representation of the record from the roster. We can do this with idgen which will create a valid id from the key for us. . Writing Data . The final add_triple simply adds the information for this property to the database. .",
    "url": "/docs/how-tos/import-data/",
    "relUrl": "/how-tos/import-data/"
  }
  ,"17": {
    "title": "Tutorials",
    "content": "Tutorials . Tutorials, as you can probably guess, are about learning how to use TerminusDB and Hub. They are to be consumed when in learning mode and usually at the beginning of your TerminusDB and Hub journey. There will also be more complex tutorials, but they are not the norm. . The idea is to provide you with a guide that you can repeat exactly. It should give the early user confidence to take further steps. Tutorials should have the minimum necessary descriptions and focus on teaching a small number of important things per tutorial. . We are always trying to improve so let us know if this section could be better. We want your tutorial, so make it and we will publish. .",
    "url": "/docs/tutorials",
    "relUrl": "/tutorials"
  }
  ,"18": {
    "title": "Discussion",
    "content": "Discussion . This section is designed to help you understand TerminusDB and TerminusHub. It is normally consumed while in ‘learning’ mode. . What matters here is context, explanation, examples built into broader text, suggestions of alternative approaches, connections to different topics. This is not the place for instructions or technical descriptions. . We are always trying to improve, so let us know if the content can be better or if you have a contribution. .",
    "url": "/docs/discussion",
    "relUrl": "/discussion"
  }
  ,"19": {
    "title": "Server",
    "content": "Server . Table of Contents .",
    "url": "/docs/reference/server",
    "relUrl": "/reference/server"
  }
  ,"20": {
    "title": "Console",
    "content": "Web Components . The TerminusDB Console is a ReactJS application that provides users with an interface for managing and querying TerminusDB. TerminusDB Console is included when you run TerminusDB, so you won’t normally need to run this on your own unless you are a developer of TerminusDB. . TerminusDB Server references this from the index page served when you access the Console from the built in webserver, on http://127.0.0.1:6363/console by default. . Table of Contents .",
    "url": "/docs/reference/web-components",
    "relUrl": "/reference/web-components"
  }
  ,"21": {
    "title": "Bootstrap",
    "content": "Bootstrap . Bootstrap is a shell script that makes use of Docker to run TerminusDB. It is currently the official supported way of running TerminusDB. . See our download center for more information. . ENV variables . TerminusDB is configurable from ENV variables that can be set by either setting ENV variables locally, or by creating a file called ENV that will be read on the start of the script. . The file ENV.example contains an example ENV file. . ENV name Default value Purpose . TERMINUSDB_DOCKER | sudo docker | Default docker command | . TERMINUSDB_CONTAINER | terminusdb-server | Name of the running container | . TERMINUSDB_REPOSITORY | terminusdb/terminusdb-server | Docker image | . TERMINUSDB_NETWORK | bridge | Docker network mode | . TERMINUSDB_TAG | The latest version tag of terminusdb-server | TerminusDB docker image version | . TERMINUSDB_STORAGE | terminusdb_storage_local | Storage volume name | . TERMINUSDB_PORT | 6363 | Port to run TerminusDB | . TERMINUSDB_LOCAL |   | Local folder to mount inside container | . TERMINUSDB_SERVER | 127.0.0.1 | Server on which TerminusDB will run | . TERMINUSDB_PASS | root | Password for accessing TerminusDB | . TERMINUSDB_AUTOLOGIN | false | Whether the administration console should automatically login | . TERMINUSDB_CONSOLE | http://127.0.0.1/console | URL for browser top open console | . TERMINUSDB_CONSOLE_BASE_URL | https://unpkg.com/@terminusdb/terminusdb-console@SOME_VERSION/console/dist/ | URL to hosted console | . TERMINUSDB_HTTPS_ENABLED | false | Enable HTTPS | . TERMINUSDB_SSL_CERT | A self signed cert | Path to SSL cert inside terminusdb-server container | . TERMINUSDB_SSL_CERT_KEY | A self-created private key | Path to private key for SSL cert inside container | .",
    "url": "/docs/reference/bootstrap",
    "relUrl": "/reference/bootstrap"
  }
  ,"22": {
    "title": "JS Client",
    "content": "JS Client . The client library and all of its functions are documented at: JavaScript Client Please visit the client documentation site for reference material on all of the functions, their parameters, etc. This documentation provides fuller reference material on the important components and how they work. . . Introduction | Package Structure | . Introduction . The Terminusdb Javascript Client allows you to connect to any terminusdb-server from Javascript programs, running either in the browser, or elsewhere. . It provides access to the full server API through programmatic function calls. . The TerminusDB Javascript Client is open source software, released under the Apache License. It can be downloaded and modified by anybody from the github repository: https://github.com/terminusdb/terminusdb-client - which is the authoritative source - all development takes place through the open source github repository. . It can be installed either as a simple script on a web-page, or as a node module, through the npm repository. See the Installation Page for more details. . Package Structure . The Javascript client is divided into 3 distinct components. . The core client functions which allow you to call the temrinus-db api directly, set state, security, etc . The query library which implements the WOQL.js query language - a native javascript fluent-style query language which abstracts away the details of the underlying document format and presents queries as simple javascript objects which interact well with code. . The view library implements the WOQL.view pattern matching library - a simple language for matching patterns with WOQL results, designed to be plugged into vizualisations. .",
    "url": "/docs/reference/js-client/",
    "relUrl": "/reference/js-client/"
  }
  ,"23": {
    "title": "Reference",
    "content": "Reference . This section is designed to help you understand TerminusDB and TerminusHub. It is normally consumed while in ‘doing’ mode. . What matters here is technical description of the machinary so you can work out what to do while you are working. It should be consistent and austere. This is not the place for discussion of problems or conceptual explanations. . We are always trying to improve, so let us know if the content can be better or if you have a contribution. .",
    "url": "/docs/reference/",
    "relUrl": "/reference/"
  }
  ,"24": {
    "title": "Release notes",
    "content": "Release notes . The various components of TerminusDB have different release notes. . TerminusDB Server v3.0.0 Release Notes . This is our TerminusDB Server v3 Emancipation release. We have removed the masters from our default branching. . New . Reset API allows resetting branch to arbitrary commit | Squash API operation now available | Default branch is now called main and not master | Added much more extensive coverage of API in the api.owl.ttl ontology | Fixed some schema errors in woql.owl.ttl | Added boolean flag (all_witnesses) for returning all or only the first witness from schema checks. | Improvements to schema checking. Most large inserts will be 40% faster | . Backwards-Incompatible Changes . Default branch will be set to main and not master, so that some calls which relied on master being default will fail. This can be fixed in all cases by doing a branch operation from master to main. | By default only one witness is now returned in WOQL queries in which the resulting database violates schema constraints. | . Bug fixes . Improved the API for organization management | Improved CORS handling on some calls | . TerminusDB Version 3.0 Release Notes . . TerminusDB Console v3.0 Release Notes . The Emancipation Release . Support for integrated distributed operation, collaboration via TerminusHub | New integrated query libraries | Full support for Terminus Server 3.0 API | Improved support for RDF - turtle loading, prefix handling | Time travel &amp; Commit navigator tools | Synchronization management tool | Branch &amp; Merge management tool | . . terminusdb-client-python v0.3.0 . New . Updated create database to take advantage of default prefixes and schema graph creation happening on server | Integrated all Revision Control API operations fully | .vars() method - add v: to woql variables | Reset allowing you to reset a branch to an arbitrary commit | Post method for CSV uploads | Triple endpoint for inserting turtle data directly to a graph | Count triples functionality added | . Bug Fixes / Improvements . Added 3 varieties of ordering specification as optional arguments to order_by | fixed bug to make order_by(“desc”) work | Empty selects no longer error | . TerminusDB Python Client v0.3.0 Release Notes .",
    "url": "/docs/release-notes/",
    "relUrl": "/release-notes/"
  }
  ,"25": {
    "title": "Python How Tos",
    "content": "Python HowTos . Guides for using TerminusDB through Python. .",
    "url": "/docs/how-tos/python",
    "relUrl": "/how-tos/python"
  }
  ,"26": {
    "title": "How Tos",
    "content": "How To Guide . How To Guides are problem driven and are designed to be a source of quick information in ‘doing mode’ when working with TerminusDB and Hub. . The idea is to provide a series of steps with a focus on the goal (getting something done!). They should address a particular problem and have no unnecessary explanation. Practical usability and not completeness is key. How Tos will not give you everything, they are like a recipe that you can alter according to your need or taste. . We are always trying to improve our docs. If you have any suggestions, let us know. And feel free to contribute. .",
    "url": "/docs/how-tos",
    "relUrl": "/how-tos"
  }
  ,"27": {
    "title": "",
    "content": ".",
    "url": "/docs/",
    "relUrl": "/"
  }
  ,"28": {
    "title": "Installation",
    "content": "Installation . This document describes how to install console into your local machine. Console is dependent on the below modules as well… . @terminusdb/terminusdb-client . @terminusdb/terminusdb-react-table . @terminusdb/terminusdb-react-graph . Most likely, if you are running console locally, it’s because you are a developer, and thus will be working with the dev branch of console. This means that you will have to point to dev branch of the above mentioned modules as well. In order to do so, simply add this line to your .npmrc inside your terminusdb-console folder. . @terminusdb:registry=https://api.bintray.com/npm/terminusdb/npm-dev . . Installation Clone from GitHub | | . Clone from GitHub . You can clone the repository into your local machine via git clone. Follow the below steps . Clone the Repo | Hop into the directory terminusdb-console | Install all dependencies | Hop into console folder | . git clone https://github.com/terminusdb/terminusdb-console.git cd terminusdb-console npm install cd ./console . In order to kick start the console, create an .env file inside console folder, where you will have to define the server end point, key and user. . TERMINUSDB_SERVER=https://127.0.0.1:6363/ . TERMINUSDB_KEY=my_key . TERMINUSDB_USER=my_user_name . After creating your .env file, in your command line you are ready to fire the console on your browser by running the below command . npm run serve . This command will automatically kick start your local console in dev mode - http://localhost:3005/ . If you also want to have local versions of the dependencies of console, such as @terminusdb/terminusdb-client, then you should clone those repos locally and use npm link to make npm use the local version. .",
    "url": "/docs/reference/web-components/installation/",
    "relUrl": "/reference/web-components/installation/"
  }
  ,"29": {
    "title": "Installation",
    "content": "Installation . . Dependencies | Install from bintray | . Dependencies . The TerminusDB Javascript Client has no external dependencies. It comes bundled with the axios libarary for communicating over HTTP, but otherwise has no third party dependencies. . Install from bintray . Installation . TerminusDB Client can be used as either a Node.js module available through the npm registry . Installation is done using the npm install command: . Using npm: . $ npm install --save @terminusdb/terminusdb-client . Minified Script . Using cdn: . &lt;script src=&quot;https://unpkg.com/@terminusdb/terminusdb-client/dist/terminusdb-client.min.js&quot;&gt;&lt;/script&gt; . Downloading: . Download the terminusdb-client.min.js file from the /dist directory and save it to your location of choice, then: . &lt;script src=&quot;http://my.saved.location/terminusdb-client.min.js&quot;&gt;&lt;/script&gt; .",
    "url": "/docs/reference/js-client/installation/",
    "relUrl": "/reference/js-client/installation/"
  }
  ,"30": {
    "title": "Installation",
    "content": "Installation . . Installation Prerequisites Docker | Git | Sudo | | Quick Start | If you’ve installed before | Using the console | To stop, attach, etc, see usage | Using the Environment | | . Prerequisites . Docker . Since this script uses the TerminusDB Docker container, you need to have Docker running. . On Windows and Mac, Docker Desktop can be downloaded here . On Linux, use your distro’s package manager, or find more information here . Git . This script is distributed via GitHub, so you will need git to clone and update it. If you don’t already have git, you can download it here . Windows users should use the application “Git Bash” for all terminal commands described below. This application comes with Git for Windows. . Sudo . Sudo is optional. As letting unprivileged users run docker is insecure, this script uses sudo by default if it is available. . Most users will not need to do anything here, sudo is installed by default on Macs and many popular Linux distros such as Fedora, Red Hat, Debian, Ubuntu and Mint. Linux users who use minimal distros such as Archlinux, are advised to install sudo and configure their sudoers file accordingly. . Windows users do not need to do anything here. . . Quick Start . Get the script in the terminusdb-bootstrap repo, cd to it . git clone https://github.com/terminusdb/terminusdb-bootstrap cd terminusdb-bootstrap . Run the container (the first time) . ./terminusdb-container run Unable to find image &#39;terminusdb/terminusdb-server:latest&#39; locally latest: Pulling from terminusdb/terminusdb-server 8f91359f1fff: Pulling fs layer 939634dec138: Pulling fs layer f30474226dd6: Pulling fs layer 32a63113e3ae: Pulling fs layer ae35de9092ce: Pulling fs layer 023c02983955: Pulling fs layer d9fa4a1acf93: Pulling fs layer [ ... ] . . If you’ve installed before . You may need to move or remove previous volumes or you may encounter bugs on the old console. . Warning: This will lead to losing local data. . ./terminusdb-container rm removing will delete storage volume Are you sure? [y/N] y . . Using the console . Ready to terminate? Open the TerminusDB Console in your web browser. . ./terminusdb-container console . Or go here: http://localhost:6363/ . . To stop, attach, etc, see usage . ./terminusdb-container USAGE: terminusdb-container [COMMAND] help show usage run run container stop stop container console launch console in web browser attach attach to prolog shell exec execeute a command inside the container rm remove volumes . That’s it! You’re ready to go! . . Using the Environment . Mount a local directory inside the container | . TERMINUSDB_LOCAL=/path/to/dir ./terminusdb-container [COMMAND] . Using the latest release | . TERMINUSDB_TAG=latest ./terminusdb-container [COMMAND] . Using the development release | . TERMINUSDB_TAG=dev ./terminusdb-container [COMMAND] . Using a specific release instead of the latest release | . TERMINUSDB_TAG=v1.1.2 ./terminusdb-container [COMMAND] . Not using sudo even when sudo is available | . TERMINUSDB_DOCKER=docker ./terminusdb-container [COMMAND] . Using podman instead of docker command | . TERMINUSDB_DOCKER=&quot;podman&quot; ./terminusdb-container [COMMAND] . See the source code to find the other environment variables that can be set. .",
    "url": "/docs/how-tos/installation/",
    "relUrl": "/how-tos/installation/"
  }
  ,"31": {
    "title": "Taking TerminusDB to the Bank",
    "content": "Taking TerminusDB to the Bank . TerminusDB is designed to enable collaboration and revision control on data assets. While git is a fantastic piece of software, it is really designed for code management, and not data management. We bring that power to the world of data. . In order to get a feel for how these collaboration features work, we can start with a classic database management problem. The bank account balance. . . . Step 1 - Create, Schema, Data, Branch and Merge . Woah - that’s a lot of action. Check out the first part here . . Step 2 - Push, Pull and Branch Management . In the first installment, we created a branch_office branch where we added some data. But the strength of the distributed model of TerminusDB is that others can work on data assets in parallel. To make use of this powerful feature, we need to make alterations in a different database. . Since we are using collaboration features, first you will need to log into hub. It is easy and you can do it from your console by pressing ‘Connect to Hub’ in the top right corner. . Check out part two here .",
    "url": "/docs/tutorials/knowledge-graph/",
    "relUrl": "/tutorials/knowledge-graph/"
  }
  ,"32": {
    "title": "Library Functions",
    "content": "Library Functions . WOQL.js includes a standard library of pattern matching functions which provide a flexible way of extracting records about the system’s internal records without having to remember the predicates that are used under the hood. . Unlike other WOQL.js functions, library functions are not part of the WOQLQuery object - they are accessed through the lib() call. Library functions have a standard signature which makes them all accessible in the same way. . Standard Arguments . All Library functions take the same three optional arguments. . Values | Variables | ResourceIdentifier | . Values . The values argument allows values to be passed for any of the internal variables which serve to constrain the query to a subset of the complete set. The Values argument comes in three forms: . […Value] - a list of specific values, where each entry sets the corresponding entry in the Variables list for the function. Any values that are not to be set can be omitted or set to null or false explicitly in which case no constraints will be applied. Example lib().classes(&quot;scm:Person&quot;) . &lt;/div&gt; specifies that only the class with ID scm:Person will be matched . | object - a json key-value object where the keys are the names of the variables to be set and the value is the value for that variable. . Example lib().classes({&#39;Class ID&#39;: &quot;scm:Person&quot;}) . &lt;/div&gt; specifies that only the class with ID scm:Person will be matched . | WOQLQuery - a woql query which serves as a constraint on any variable mentioned in the query . Example let [clist] = vars(&quot;Class List&quot;) lib().classes(member(clist, [&#39;scm:Person&#39;, &#39;scm:Animal&#39;])) . &lt;/div&gt; specifies that only the class with ID scm:Person and scm:Animal will be matched . | . Variables . Each library function defines an internal list of variable names which are used by default to represent the results of the library query - the variables’ names can be overriden by passing in an alternative list of variable names. As with values, a null or false or an omitted variable means that the default will be used for that position . Example let [cid, cname] = vars(&quot;Class&quot;, &quot;Class Label&quot;) lib().classes(false, [cid, cname]) . ResourceIdentifier . Each library query is associated with a specific graph - by default, the graph resource identifier is set to the appropriate graph of the current default database. This can be changed by setting the ResourceIdentifier argument to the desired graph. . Example lib().classes(false, false, &#39;schema/extra&#39;) . . Library Functions with Standard Arguments . classes Retreives a list of classes from the schema. For each class matched, the following properties are returned . Syntax classes(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description Prefix . Class ID | IRI of the class |   | . Class Name | Label of the Class | (rdfs:label) | . Description | Description of the Class | (rdfs:comment) | . Parents | Parent classes | (rdfs:subClassOf) | . Children | Child classes | (rdfs:subClassOf) | . Abstract | Abstract class designation | (system:tag system:abstract) | . Returns WOQLQuery containing the classes pattern matching expression . Example let [cls] = vars(&quot;Class ID&quot;) lib().classes(eq (cls, &#39;scm:X&#39;)) //retrieves the class with IRI scm:X . . properties Retreives the list of properties from the schema. For each property matched, the following properties are returned . Syntax properties(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description Prefix . Property ID | IRI of the property |   | . Property Name | Label of the property | (rdfs:label) | . Property Domain | Domain of the property | (rdfs:domain) | . Property Type | Object Property or Data Property | (rdfs:subClassOf) | . Property Range | Range of the property | (rdfs:range) | . Property Description | Description | (rdfs:comment) | . Returns WOQLQuery containing the properties pattern matching expressionn . Example let [prop] = vars(&quot;Property Type&quot;) lib().classes(eq(prop, &#39;Object&#39;)) //retrieves all object properties . . graphs Retreives the list of graphs for the current database for each commit . Syntax graphs(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description Prefix . Graph ID | resource id of the graph |   | . Graph Type | schema or instance or inference |   | . Branch ID | id of the branch (if the commit is branch head | ref:branch_name) | . Commit ID | id of the commit that points to the graph | (ref:commit_id) | . Graph IRI | Graph IRI |   | . Branch IRI | Branch IRI |   | . Commit IRI | Commit IRI |   | . Returns WOQLQuery containing the graphs pattern matching expression . Example let [br] = vars(&quot;Branch ID&quot;) lib().graphs().not().eq(br, &#39;&#39;) . . branches Retreives the list of branches for the current database . Syntax branches(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description Prefix . Branch ID | resource id of the branch | (ref:branch) | . Time | Time of last commit | (ref:commit_timestamp) | . Commit ID | id of the commit that points to the graph | (ref:ref_commit) | . Branch IRI | Branch IRI |   | . Commit IRI | Commit IRI |   | . Returns WOQLQuery containing the branches pattern matching expression . Example let [ci] = vars(&quot;Branch ID&quot;) lib().branches(eq(ci, &#39;main&#39;)) //retrieves branch with id main . . objects Retreives the list of object ids and their types . Syntax objects(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description . Object Type | type of the object | . Object ID | IRI of the object | . Returns WOQLQuery containing the objects pattern matching expression . Example let [ot] = vars(&quot;Object Type&quot;) lib().objects(member(ot, [&#39;scm:Y&#39;, &#39;scm:Z&#39;])) //retrieves all objects of type scm:Z and scm:Y . . property values Retreives the list of property values for objects in the database . Syntax property_values(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description . Object ID | IRI of the object | . Property ID | IRI of the property | . Property Value | The value of the property (literal or JSON-LD document) | . &lt;span class=”param-type”Value ID &lt;/span&gt; | IRI of the value (object properties) | . Value Class | Class of the value (object properties) | . Returns WOQLQuery containing the property values pattern matching expression . Example let [p] = vars(&quot;Property ID&quot;) lib().property_values(eq(p, &#39;rdf:type&#39;)) //retrieves all type properties from the DB . . object metadata Retreives the list of objects with metadata about their types . Syntax object_metadata(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description Prefix . Object ID | IRI of the object | (rdfs:label) | . Description | Object description | (rdfs:comment) | . Type ID | IRI of the type of the object | (rdf:type) | . Type Name | Label of the type | (rdfs:label from schema) | . Type Description | Description of the type | (rdfs:comment from schema) | . Returns WOQLQuery containing the object metadata pattern matching expression . Example let [t] = vars(&quot;Type ID&quot;) lib().object_metadata(eq(t, &#39;scm:Z&#39;)) //retrieves all objects of type scm:Z with their metadata . . property metadata Retreives the list of properties with metadata about their types . Syntax property_metadata(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description Prefix . Object ID | IRI of the object | (rdfs:label) | . Property ID | IRI of the property |   | . Property Name | Property label | (rdfs:label) | . Property Value | Property Value |   | . Property Description | Property description | (rdfs:comment ) | . Returns WOQLQuery containing the property metadata pattern matching expression . Example lib().property_metadata() //retrieves all objects of type scm:Z with their metadata . . commits Retreives the list of commits . Syntax commits(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description . Commit ID | ID of the commit | . Commit IRI | IRI of the commit | . Time | timestamp of commit | . Author | Author of commit | . Message | commit message | . Parent ID | Commit ID of parent commit | . Parent IRI | IRI of parent commit | . Children | Array of child commits | . Returns WOQLQuery containing the commits pattern matching expression . Example lib().commits() . . commit chain Retrieves chains of commits from one commit to another . Syntax commit_chain(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description . Head IRI | IRI of commit as chain starting point | . Tail IRI | IRI of commit as chain ending point | . Path | Path traversed from head to tail | . Returns WOQLQuery containing the commit chain pattern matching expression . Example lib().commit_chain() . . repos Retrieves information about remotes and their repositories in the repository graph . Syntax repos(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description . Repository IRI | IRI of commit as chain starting point | . Repository Name | name of the repositoriy (ref:repository_name) | . Path | Path traversed from head to tail | . Returns WOQLQuery containing the repository pattern matching expression . Example lib().repos(false, false, &quot;admin/MyTestDB/_meta&quot;) //note: the resource id for repository graphs must be specified explicitly for the db . . dbs Retrieves information about the databases on the server . Syntax dbs(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description . DB Name | Name of the database (system:database_name) | . DB ID | IRI of the database document | . Organization | ID of the organization that owns the DB | . Description | Description of the DB | . DB IRI | IRI of the database document in the system graph | . Organization IRI | IRI of the organization document in the system graph | . Returns WOQLQuery containing the database pattern matching expression . Example lib().dbs() . . prefixes Retrieves the list of IRI prefixes in use in the DB . Syntax prefixes(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description . Prefix | The prefix string (eg. doc) | . URI | The full URI/IRI that the prefix refers to | . Prefix Pair IRI | the IRI of the document that contains the prefix / URL | . Returns WOQLQuery containing the prefix pattern matching expression . Example lib().prefixes() . . insert prefix Inserts a new prefix pair into the database . Syntax insert_prefix(Values, Variables, ResourceIdentifier) . Arguments: Arguments Types Requirement . Values | must contain [prefix, IRI] as either variables or string literals | Mandatory | . Variables | single variable, default is: Prefix Pair IRI - variable which will contain the generated IRI of the prefix pair | Mandatory | . Returns WOQLQuery containing the prefix insertion expression . Example lib().insert_prefix([&#39;foaf&#39;, &quot;http://xmlns.com/foaf/0.1/&quot;]) . . document classes Retrieves the list of document classes from the DB . Syntax document_classes(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description Prefix . Class ID | IRI of the class |   | . Class Name | Label of the Class | (rdfs:label) | . Description | Description | (rdfs:comment) | . Parents | Parents classes | (rdfs:subClassOf) | . Child | Child classes | (rdfs:subClassOf) | . Abstract | Abstract class designation | (system:tag system:abstract) | . Returns WOQLQuery containing the classes pattern matching expression . Example lib().document_classes() . . concrete document classes Retrieves the list of non-abstract document classes from the DB . Syntax concrete_document_classes(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description Prefix . Class ID | IRI of the class |   | . Class Name | Label of the Class | (rdfs:label) | . Description | Description | (rdfs:comment) | . Parents | Parents classes | (rdfs:subClassOf) | . Child | Child classes | (rdfs:subClassOf) | . Abstract | Abstract class designation | (system:tag system:abstract) | . Returns WOQLQuery containing the classes pattern matching expression . Example lib().concrete_document_classes() . . document metadata Retreives the list of documents with metadata about their types . Syntax document_metadata (Values, Variables, ResourceIdentifier) . Default Variables: Variables Description Prefix . Document ID | IRI of the document |   | . Name | document label | (rdfs:label) | . Description | Description | (rdfs:comment) | . Type ID | IRI of the type of the document | (rdf:type) | . Type Name | Label of the type | (rdfs:label from schema) | . Type Description | Description of the type | (rdfs:comment from schema) | . Returns WOQLQuery containing the object metadata pattern matching expression . Example lib().document_metadata() . . documents Retreives the list of document ids and their types . Syntax documents(Values, Variables, ResourceIdentifier) . Default Variables: Variables Description . Document Type | type of the document | . Document ID | IRI of the document | . Returns WOQLQuery containing the objects pattern matching expression . Example lib().documents() . . Commit Graph Navigation . The WOQL.js library also provides a set of functions for navigation of the commit graph by branch, time and commit id. These functions do not take the same arguments as the standard functions above. There are two flavours of all graph navigation functions - one that returns all the meta-data for each commit, the other that returns only the commit ids - to allow these functions to be conveniently joined with other queries and filters. . commit chain full Retreives the commit chain with full details of all commits (combines commits() and commit_chain()) . Syntax commit_chain_full(Values, ResourceIdentifier) . Arguments: Arguments Types Requirement . Values | values array as per standard arguments | Mandatory | . ResourceIdentifier | graph identifier (defaults to _commits) | Mandatory | . Returns WOQLQuery containing the full commit chain pattern matching expression . Example lib().commit_chain_full() . . first commit Retreives information about the first commit in the database . Syntax first_commit() . Arguments: None - variable names are as per commits() function above . Returns WOQLQuery containing the first commit pattern matching expression: returns the same variables as the lib().commits() function . Example lib().first_commit() . . active commit Retrieves the details of the commit that was active at the given timestamp on the given branch . Syntax active_commit(BranchID, Timestamp) . Arguments: Arguments Types Requirement . BranchID | (string*) - the id of the branch to aim for (for disambiguation when there are multiple child commits) | Mandatory | . Timestamp | (string or decimal) - the timestamp (or variable containing the timestamp) of interest - defaults to now | Mandatory | . Arguments: None - variable names are as per commits() function above . Returns WOQLQuery containing the active commit pattern matching expression: returns the same variables as the lib().commits() function . Example lib().active_commit(&#39;main&#39;) . . commit history Retreives the metadata for the passed CommitID and its parent commits - up to a total of Count steps (including the passed CommitID) . Syntax commit_history(CommitID, Count) . Arguments: Arguments Types Requirement . CommitID | (string*) - the id of the commit to retrieve the history starting from (included in results) | Mandatory | . Count | (string or integer) - an integer or variable containing an integer representing the number of steps to include in the commit history - defaults to 10 | Optional | . Returns WOQLQuery containing the commit history pattern matching expression: returns the same variables as the lib().commits() function for each entry . Example and( lib().active_commit_id(&#39;main&#39;, false, &quot;Current Head ID&quot;), lib().commit_history(&quot;v:Current Head ID&quot;, 5) ) . . commit history Retreives the metadata for the parent commits of the passed CommitID - up to a total of Count steps (not including the passed CommitID) . Syntax previous_commits(CommitID, Count) . Arguments: Arguments Types Requirement . CommitID | (string*) - the id of the commit to retrieve the previous commits starting from (not included in results) | Mandatory | . Count | (string or integer) - an integer or variable containing an integer representing the number of steps to include in the commit history - defaults to 1 | Optional | . Returns WOQLQuery containing the previous commits pattern matching expression: returns the same variables as the lib().commits() function for each entry . Example and( lib().active_commit_id(&#39;main&#39;, false, &quot;Current Head ID&quot;), lib().previous_commits(&quot;v:Current Head ID&quot;, 5) ) . . commit future Retreives the metadata for the passed CommitID and its future commits on branch BranchID - up to a total of Count steps (including the passed CommitID) . Syntax commit_future(CommitID, BranchID, Count) . Arguments: Arguments Types Requirement . CommitID | (string*) - the id of the commit to retrieve the future starting from (included in results) | Mandatory | . BranchID | (string*) - the id of the branch to aim for (for disambiguation when there are multiple child commits) | Mandatory | . Count | (string or integer) - an integer or variable containing an integer representing the number of steps to include in the commit future - defaults to 10 | Optional | . Returns WOQLQuery containing the commit history pattern matching expression: returns the same variables as the lib().commits() function for each entry . Example lib().commit_future(&#39;bi1qqga9sxlzgvv061b3zpe48mmjtbb&#39;, &quot;main&quot;, 5) . . next commits Retreives the metadata for child commits of the passed CommitID on branch BranchID - up to a total of Count steps (not including the passed CommitID) . Syntax next_commits(CommitID, BranchID, Count) . Arguments: Arguments Types Requirement . CommitID | (string*) -the id of the commit to retrieve the next commits starting from (not included in results) | Mandatory | . BranchID | the id of the branch to aim for (for disambiguation when there are multiple child commits) | Mandatory | . Count | (string or integer) - an integer or variable containing an integer representing the number of steps to include in the commit future - defaults to 1 | Optional | . Returns WOQLQuery containing the commit history pattern matching expression: returns the same variables as the lib().commits() function for each entry . Example lib().next_commits(&#39;bi1qqga9sxlzgvv061b3zpe48mmjtbb&#39;, &quot;main&quot;, 4) . . active commit id Retrieves the ID of the commit that was active at the given timestamp on the given branch - result is stored in CommitIDVar . Syntax active_commit_id(CommitID, Timestamp, CommitIDVar) . Arguments: Arguments Types Requirement . CommitID | (string*) - the id of the commit to retrieve the history for | Mandatory | . Timestamp | (string or decimal) - the Unix timestamp (or variable containing the timestamp) of interest - defaults to now | Optional | . CommitIDVar | (string) - the name of the variable in which to store the matched IDs (defaults to “Commit ID”) | Optional | . Returns WOQLQuery containing the pattern matching expression: returns one row per CommitIDVar value . Example lib().active_commit_id(&#39;main&#39;) . . history ids Retrieves the ids of the passed CommitID and the ids of its parents - up to a total of count ids (including the passed CommitID), the results are stored in CommitIDVar . Syntax history_ids(CommitID, Count, CommitIDVar) . Arguments: Arguments Types Requirement . CommitID | (string*) - the id of the commit to retrieve the history for | Mandatory | . Count | (string or integer) - an integer or variable containing an integer representing the number of steps to include in the commit history - defaults to 10 | Optional | . CommitIDVar | (string) - the name of the variable in which to store the matched IDs (defaults to “Commit ID”) | Optional | . Returns WOQLQuery containing the pattern matching expression: returns one row per CommitIDVar value . Example and( lib().active_commit_id(&#39;main&#39;, false, &quot;Current Head ID&quot;), lib().history_ids(&quot;v:Current Head ID&quot;, 5) ) . . previous commit ids Retrieves the ids of the parent commits of the passed CommitID - up to a total of count ids (not including the passed CommitID), the results are stored in CommitIDVar . Syntax previous_commit_ids(CommitID, Count, CommitIDVar) . Arguments: Arguments Types Requirement . CommitID | (string*) - the id of the commit to retrieve the previous commits starting fromthe id of the commit to retrieve the history for | Mandatory | . Count | (string or integer) - an integer or variable containing an integer representing the number of steps to include in the commit history - defaults to 10 | Optional | . CommitIDVar | (string) - the name of the variable in which to store the matched IDs (defaults to “Commit ID”) | Optional | . Returns WOQLQuery containing the pattern matching expression: returns one row per CommitIDVar value . Example and( lib().active_commit_id(&#39;main&#39;, false, &quot;Current Head ID&quot;), lib().previous_commit_ids(&quot;v:Current Head ID&quot;, 5) ) . . future ids Retrieves the ids of the passed CommitID and the ids of its parents - up to a total of count ids (including the passed CommitID), the results are stored in CommitIDVar . Syntax future_ids(CommitID, BranchID, Count, CommitIDVar) . Arguments: Arguments Types Requirement . CommitID | (string*) - the id of the commit to retrieve the history for | Mandatory | . BranchID | (string*) - the id of the branch to aim for (for disambiguation when there are multiple child commits) | Mandatory | . Count | (string or integer) - an integer or variable containing an integer representing the number of steps to include in the commit history - defaults to 10 | Optional | . CommitIDVar | (string) - the name of the variable in which to store the matched IDs (defaults to “Commit ID”) | Mandatory | . Returns WOQLQuery containing the pattern matching expression: returns one row per CommitIDVar value . Example lib().future_ids(&quot;bi1qqga9sxlzgvv061b3zpe48mmjtbb&quot;, &quot;main&quot;, 4) . . next commit ids Retrieves the ids of the child commits of the passed CommitID - up to a total of count ids (not including the passed CommitID), the results are stored in CommitIDVar . Syntax next_commit_ids(CommitID, BranchID, Count, CommitIDVar) . Arguments: Arguments Types Requirement . CommitID | (string*) - the id of the commit to retrieve the history for | Mandatory | . BranchID | (string*) - the id of the branch to aim for (for disambiguation when there are multiple child commits) | Mandatory | . Count | (string or integer) - an integer or variable containing an integer representing the number of steps to include in the commit chain - defaults to 1 | Optional | . CommitIDVar | (string) - the name of the variable in which to store the matched IDs (defaults to “Commit ID”) | Mandatory | . Returns WOQLQuery containing the pattern matching expression: returns one row per CommitIDVar value . Example lib().next_commit_ids(&quot;bi1qqga9sxlzgvv061b3zpe48mmjtbb&quot;, &quot;main&quot;, 4) . .",
    "url": "/docs/reference/woql/library",
    "relUrl": "/reference/woql/library"
  }
  ,"33": {
    "title": "Manage Collaborators",
    "content": "Manage Collaborators . Collaboration is at the heart of TerminusDB and TerminusHub. We want to make it as easy as possible for you to add and manage collaborators. . . Section 1 - Add and Manage Collaborators . In the TerminusDB console, you can add collaborators in the ‘Collaborate’ tab. You can choose the database to share, the associated permissions and the collaborator’s ID or email address. If you want to add multiple collaborators, please seperate with a comma. . . To manage collaborators and permissions, just click on the collaborate tab and you will see a list with associated permissions. . . Section 2 - Manage Private Collaborators . If you have signed up for a pro-tier account on TerminusHub, you manage your private collaborators in the same way as above. .",
    "url": "/docs/how-tos/manage-collaborators/",
    "relUrl": "/how-tos/manage-collaborators/"
  }
  ,"34": {
    "title": "WOQL Non Primitives",
    "content": "Non Primitive Functions . WOQL Literals, Prefixes &amp; IRI Constants . string Status: Stable . Generates explicitly a JSON-LD string literal from the input . Syntax string(Val1) . Arguments Arguments Types Requirement . Val1 | (literal*) - any literal type | Mandatory | . Returns A JSON-LD string literal . Example string(1) //returns { &quot;@type&quot;: &quot;xsd:string&quot;, &quot;@value&quot;: &quot;1&quot; } . . . literal Status: Stable . Generates explicitly a JSON-LD string literal from the input . Syntax literal(Val, Type) . Arguments Arguments Types Requirement . Val | (literal*) - any literal type | Mandatory | . Type | (string*) - an xsd or xdd type | Mandatory | . Returns A JSON-LD literal . Example literal(1, &quot;nonNegativeInteger&quot;) //returns { &quot;@type&quot;: &quot;xsd:nonNegativeInteger&quot;, &quot;@value&quot;: 1 } . . iri Status: Stable . Explicitly sets a value to be an IRI - avoiding automatic type marshalling . Syntax iri(Val1) . Arguments Arguments Types Requirement . Val1 | (string*) - string which will be treated as an IRI | Mandatory | . Returns A JSON-LD IRI value . Example iri(&quot;dc:title&quot;) //returns { &quot;@type&quot;: &quot;woql:Node&quot;, &quot;woql:node&quot;: &quot;dc:title&quot; } . . Basic Helper Functions . query Status: Stable . Generates an empty WOQLQuery object . Syntax query() . Arguments None . Returns An empty WOQLQuery object . Example let q = query() //then q.triple(1, 1) ... . . json Status: Stable . Translates between the JSON-LD and object version of a query - if an argument is passed, the query object is created from it, if none is passed, the current state is returned as a JSON-LD . Syntax json(JSONLD) . Arguments Arguments Types Requirement . JSONLD | (json) - optional JSON-LD woql document encoding a query | Mandatory | . Returns either a JSON-LD or a WOQLQuery object . Example let q = triple(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) let qjson = q.json() let p = json(qjson) /*q and p both contain: {&quot;@type&quot;: &quot;woql:Triple&quot;, &quot;woql:subject&quot;: { &quot;@type&quot;: &quot;woql:Node&quot;, &quot;woql:node&quot;: &quot;doc:a&quot;}, &quot;woql:predicate&quot;: .... } }*/ . . vars Status: Stable . Generates javascript variables for use as WOQL variables within a query . Syntax vars(...Varnames) . Arguments Arguments Types Requirement . Vars | ([string*]) an array of strings, each of which will server as a variable | Mandatory | . Returns an array of javascript variables which can be dereferenced using the array destructuring operation . Example const [a, b, c] = vars(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) //a, b, c are javascript variables which can be used as WOQL variables in subsequent queries . . Compound Functions . Shorthand Compound Functions . Shorthand compound functions provide shorthand forms for commonly used functions to avoid having to write the same basic patterns repeatedly . star Status: Stable . Generates a query that by default matches all triples in a graph . Syntax star(Graph, Subject, Object, Predciate) . Arguments Arguments Types Requirement . Graph | (string) - Option Resource String identifying the graph to be searched for the pattern | Optional | . Subject | (string) - Optional IRI of triple’s subject or a variable | Optional | . Predicate | (string) - Optional IRI of a property or a variable | Optional | . Object | (string) - Optional IRI of a node or a variable, or a literal | Optional | . Returns A WOQLQuery which contains the pattern matching expression . Example star(&quot;schema/main&quot;) //will return every triple in schema/main graph . . all Status: Stable Generates a query that by default matches all triples in a graph - identical to star() except for order of arguments . Syntax all(Subject, Object, Predciate, Graph) . Arguments Arguments Types Requirement . Subject | (string) - Optional IRI of triple’s subject or a variable | Optional | . Predicate | (string) - Optional IRI of a property or a variable | Optional | . Object | (string) - Optional IRI of a node or a variable, or a literal | Optional | . Graph | (string) - Optional Resource String identifying the graph to be searched for the pattern | Optional | . Returns A WOQLQuery which contains the pattern matching expression . Example all(&quot;mydoc&quot;) //will return every triple in the instance/main graph that has &quot;doc:mydoc&quot; as its subject . . all Status: Stable . Deletes all triples in the graph . Syntax nuke(Graph) . Arguments Arguments Types Requirement . Graph | (string) - Optional Resource String identifying the graph from which all triples will be removed | Optional | . Returns A WOQLQuery which contains the deletion expression . Example nuke(&quot;schema/main&quot;) //will delete everything from the schema/main graph . . Compound Schema Functions . Compound schema functions are compound functions specifically designed to make generating schemas easier. They generate multiple inserts for each function . add class Status: Stable . Adds a new class definition to the schema . Syntax add_class(ClassIRI, Graph) . Arguments Arguments Types Requirement . ClassIRI | (string*) - IRI or variable containing IRI of the new class to be added (prefix default to scm) | Mandatory | . Graph | (string) - Optional Resource String identifying the schema graph into which the class definition will be written | Optional | . Returns A WOQLQuery which contains the add class expression . Example add_class(&quot;MyClass&quot;) //equivalent to add_quad(&quot;MyClass&quot;, &quot;type&quot;, &quot;owl:Class&quot;, &quot;schema/main&quot;) . . add property Status: Stable . Adds a new property definition to the schema . Syntax add_property(PropIRI, RangeType, Graph) . Arguments Arguments Types Requirement . PropIRI | (string*) - IRI or variable containing IRI of the new property to be added (prefix default to scm) | Mandatory | . RangeType | (string) - optional IRI or variable containing IRI of the range type of the new property (defaults to xsd:string) | Optional | . Graph | (string) - Optional Resource String identifying the schema graph into which the property definition will be written | Optional | . Returns A WOQLQuery which contains the add property expression . Example add_property(&quot;myprop&quot;) /*equivalent to add_quad(&quot;myprop&quot;, &quot;type&quot;, &quot;owl:DatatypeProperty&quot;, &quot;schema/main&quot;) .add_quad(&quot;myprop&quot;, &quot;range&quot;, &quot;xsd:string&quot;, &quot;schema/main&quot;)*/ . . doctype Status: Stable . Adds a new document class to the schema . Syntax doctype(ClassIRI, Graph) . Arguments Arguments Types Requirement . ClassIRI | (string*) - IRI or variable containing IRI of the new document class to be added (prefix default to scm) | Mandatory | . Graph | (string) - Optional Resource String identifying the schema graph into which the class definition will be written | Optional | . Returns A WOQLQuery which contains the add document class expression . Example doctype(&quot;MyClass&quot;) /*equivalent to add_quad(&quot;MyClass&quot;, &quot;type&quot;, &quot;owl:Class&quot;, &quot;schema/main&quot;) .add_quad(&quot;MyClass&quot;, &quot;subClassOf&quot;, &quot;system:Document&quot;, &quot;schema/main&quot;) */ . . delete class Status: Experimental / Unstable . Deletes a class - including all properties and incoming links - from the schema . Syntax delete_class(ClassIRI, Graph) . Arguments Arguments Types Requirement . ClassIRI | IRI or variable containing IRI of the class to be deleted (prefix default to scm) | Mandatory | . Graph | (string) - Optional Resource String identifying the schema graph from which the class definition will be deleted | Optional | . Returns A WOQLQuery which contains the class deletion expression . Example delete_class(&quot;MyClass&quot;) . . delete property Status: Experimental / Unstable . Deletes a property from the schema and all its references incoming and outgoing . Syntax delete_property(PropIRI, Graph) . Arguments Arguments Types Requirement . PropIRI | (string*) - IRI or a variable containing IRI of the property to be deleted (prefix defaults to scm) | Mandatory | . Graph | (string) - Optional Resource String identifying the schema graph from which the property definition will be deleted | Optional | . Returns A WOQLQuery which contains the property deletion expression . Example delete_property(&quot;MyProp&quot;) . . schema Status: Deprecated . Generates an empty query object - identical to query - included for backwards compatibility as before v3.0, the schema functions were in their own namespace. . Syntax schema(Graph) . Arguments Arguments Types Requirement . Graph | (string) - Optional Resource String identifying the graph which will be used for subsequent chained schema calls | Optional | . Returns An empty WOQLQuery with the internal schema graph pointes set to Graph . Example schema(&quot;schema/dev&quot;).add_class(&quot;X&quot;) //equivalent to add_class(&quot;X&quot;, &quot;schema/dev&quot;) - non-deprecated version . . Builder / Partial Functions . Builder functions are different from other WOQL functions in that they cannot be used in isolation - they produce partial functions in isolation and need to be chained onto other functions in order to form complete functions in their own right. Builder functions must be chained after a function that provides at least a subject (triple, add_triple, add_quad, delete_triple). Multiple builder functions can be chained together. . schema Status: Stable . Specifies the identity of a node that can then be used in subsequent builder functions. Note that node() requires subsequent chained functions to complete the triples / quads that it produces - by itself it only generates the subject. . Syntax node(NodeID, ChainType) . Arguments Arguments Types Requirement . NodeID | (string*) The IRI of a node or a variable containing an IRI which will be the subject of the builder functions | Mandatory | . ChainType | (string) Optional type of builder function to build (can be Triple, Quad, AddTriple, AddQuad, DeleteTriple, DeleteQuad) - defaults to Triple | Optional | . Returns A WOQLQuery which contains the partial Node pattern matching expression . Example node(&quot;mydoc&quot;).label(&quot;my label&quot;) //equivalent to triple(&quot;mydoc&quot;, &quot;label&quot;, &quot;my label&quot;) . . insert Status: Stable . Inserts a single triple into the database declaring the Node to have type Type, optionally into the specified graph . Syntax insert(Node, Type, Graph) . Arguments Arguments Types Requirement . Node | (string*) - IRI string or variable containing the IRI of the node to be inserted | Mandatory | . Type | (string*) - IRI string or variable containing the IRI of the type of the node | Mandatory | . Graph | (string) - Optional Graph resource identifier | Optional | . Returns A WOQLQuery which contains the insert expression . Example insert(&quot;mydoc&quot;, &quot;MyType&quot;) //equivalent to add_triple(&quot;mydoc&quot;, &quot;type&quot;, &quot;MyType&quot;) . . insert Status: Stable . Sets the graph resource ID that will be used for subsequent chained function calls . Syntax graph(Graph) . Arguments Arguments Types Requirement . Graph | Graph Resource String literal | Mandatory | . Returns A WOQLQuery which contains the partial Graph pattern matching expression . Example node(&quot;MyClass&quot;, &quot;AddQuad&quot;).graph(&quot;schema/main&quot;).label(&quot;My Class Label&quot;) //equivalent to add_quad(&quot;MyClass&quot;, &quot;label&quot;, &quot;My Class Label&quot;, &quot;schema/main&quot;) . . abstract Status: Stable . Adds an abstract designation to a class . Syntax abstract(Graph, Subject) . Arguments Arguments Types Requirement . Graph | (string) optional Graph Resource String literal - defaults to “schema/main” | Optional | . Subject | (string) optional IRI or variable containing IRI of the subject | Optional | . Returns A WOQLQuery which contains the Abstract tag expression . Example node(&quot;MyClass&quot;, &quot;AddQuad&quot;).abstract() //equivalent to add_quad(&quot;MyClass&quot;, &quot;system:tag&quot;, &quot;system:abstract&quot;,&quot;schema/main&quot;) . . property Status: Stable . Creates a property in the schema or adds a property to the instance data, or creates a property matching rule, depending on context . Syntax property(PropIRI, Type_or_Value) . Arguments Arguments Types Requirement . PropIRI | (string*) - the IRI of the property or a variable containing the property | Mandatory | . Type_or_Value | (string or literal*) - the value of the property (instance) or the type of the property (schema) | Mandatory | . Returns A WOQLQuery which contains the property matching / insert expression . Example doctype(&quot;X&quot;).property(&quot;Y&quot;, &quot;string&quot;) //creates a document type X with a property Y of type string . . domain Status: Stable . Specifies the domain of a property in a property chain . Syntax domain(ClassIRI) . Arguments Arguments Types Requirement . ClassIRI | (string *) IRI of class or variable containing IRI | Mandatory | . Returns A WOQLQuery which contains the domain expression . Example add_property(&quot;MyProp&quot;).domain(&quot;MyClass&quot;) . . label Status: Stable . Adds a label to an element in a chain using the rdfs:label predicate . Syntax label(Label, Lang) . Arguments Arguments Types Requirement . Label | (string *) string literal containing label or variable containing string | Mandatory | . Lang | (string) optional language tag (e.g. “en”) | Optional | . Returns A WOQLQuery which contains the label in the rdfs:label predicate . Example add_class(&quot;MyClass&quot;).label(&quot;My Class Label&quot;) //creates the class and gives it a label . . description Status: Stable . Adds a description to an element in a chain using the rdfs:comment predicate . Syntax description(Comment, Lang) . Arguments Arguments Types Requirement . Comment | (string *) string literal containing label or variable containing string | Mandatory | . Lang | (string) optional language tag (e.g. “en”) | Optional | . Returns A WOQLQuery which contains the description in the rdfs:comment predicate . Example let [doc] = vars(&quot;doc&quot;) node(doc).description(&quot;My Class Description&quot;) //matches any document with the given description . . description Status: Stable . Adds parent class clause(s) to a chain using the rdfs:subClassOf predicate . Syntax parent(...ParentIRIs) . Arguments Arguments Types Requirement . ParentIRI | ([string*]) - list of class IRIs or variables containing class IRIs representing parent classes of the current class | Mandatory | . Returns A WOQLQuery which contains the parent expression . Example let [doc] = vars(&quot;doc&quot;) add_class(&quot;Y&quot;).parent(&quot;X&quot;) //creates class Y as a subClass of class X . . max Status: Stable . Adds a maximum cardinality constraint to an add_property chain . Syntax max(Count) . Arguments Arguments Types Requirement . Count | (integer or string*) - a non negative integer or a variable containing a non-negative integer | Mandatory | . Returns A WOQLQuery which contains the maximum cardinality expression . Example add_property(&quot;MyProp&quot;).domain(&quot;X&quot;).max(1) //creates a string property in class X with a maximum cardinality of 1 . . min Status: Stable Adds a minimum cardinality constraint to an add_property chain . Syntax min(Count) . Arguments Arguments Types Requirement . Count | (integer or string*) - a non negative integer or a variable containing a non-negative integer | Mandatory | . Returns A WOQLQuery which contains the minimum cardinality expression . Example add_property(&quot;MyProp&quot;).domain(&quot;X&quot;).min(1) //creates a string property in class X with a minimum cardinality of 1 . . cardinality Status: Stable . Adds an exact cardinality constraint to an add_property chain . Syntax cardinality(Count) . Arguments Arguments Types Requirement . Count | (integer or string*) - a non negative integer or a variable containing a non-negative integer | Mandatory | . Returns A WOQLQuery which contains the cardinality expression . Example add_property(&quot;MyProp&quot;).domain(&quot;X&quot;).cardinality(1) //creates a string property in class X with an exact cardinality of 1 . . insert data Status: Stable . Inserts data as an object - enabling multiple property values to be inserted in one go . Syntax insert_data(Data, Graph) . Arguments Arguments Types Requirement . Data | (object*) a json object containing id (string*) IRI or variable containing IRI of the entity to be inserted key (string*) keys representing properties that the entity has (label, description, type and any other valid property for the object) | Mandatory | . Graph | (string) an optional graph resource identifier (defaults to “instance/main” if no using or into is specified) | Optional | . Returns A WOQLQuery which contains the insertion expression . Example let data = {id: &quot;doc:joe&quot;, type: &quot;Person&quot;, label: &quot;Joe&quot;, description: &quot;My friend Joe&quot;, age: 42 } insert_data(data) . . insert class data Status: Stable . Inserts data about a class as a json object - enabling a class and all its properties to be specified in a single function . Syntax insert_class_data(Data, Graph) . Arguments Arguments Types Requirement . Data | (object*) a json object containing id (string*) IRI or variable containing IRI of the class to be inserted key (string*) keys representing properties that the class has (label, description, type and any other valid property for the object) | Mandatory | . Graph | (string) an optional graph resource identifier (defaults to “schema/main” if no using or into is specified) | Optional | . Returns A WOQLQuery which contains the insertion expression . Example let data = { id: &quot;Robot&quot;, label: &quot;Robot&quot;, parent: [&quot;X&quot;, &quot;MyClass&quot;] } insert_class_data(data) . . insert doctype data Status: Stable . Inserts data about a document class as a json object - enabling a document class and all its properties to be specified in a single function . Syntax insert_doctype_data(Data, Graph) . Arguments Arguments Types Requirement . Data | (object*) a json object containing id (string*) IRI or variable containing IRI of the class to be inserted key (string*) keys representing properties that the document class has (label, description, type and any other valid property for the object) | Mandatory | . Graph | (string) an optional graph resource identifier (defaults to “schema/main” if no using or into is specified) | Optional | . Returns A WOQLQuery which contains the insertion expression . Example let data = { id: &quot;Person&quot;, label: &quot;Person&quot;, age: { label: &quot;Age&quot;, range: &quot;xsd:integer&quot;, max: 1 } } insert_doctype_data(data) . . insert property data Status: Stable . Inserts data about a document class as a json object - enabling a document class and all its properties to be specified in a single function . Syntax insert_property_data(Data, Graph) . Arguments Arguments Types Requirement . Data | (object*) a json object containing id (string*) IRI or variable containing IRI of the property to be inserted key (string*) keys representing properties that the property has (label, description, type and any other valid property for the object) | Mandatory | . Graph | (string) an optional graph resource identifier (defaults to “schema/main” if no using or into is specified) | Optional | . Returns A WOQLQuery which contains the insertion expression . Example let data = { id: &quot;prop&quot;, label: &quot;Property&quot;, description: &quot;prop desc&quot;, range: &quot;X&quot;, domain: &quot;X&quot;, max: 2, min: 1 } insert_property_data(data) . .",
    "url": "/docs/reference/woql/nonprimitives",
    "relUrl": "/reference/woql/nonprimitives"
  }
  ,"35": {
    "title": "Other ways of installing TerminusDB",
    "content": "Other ways of installing TerminusDB . . Linux Debian or Ubuntu Rust | SWIPL | Terminus Server | | Fedora or Red Hat Rust | SWIPL | SWIPL libraries | Terminus Server | | Arch Linux Rust | Library dependencies | SWIPL libraries | Terminus Server | | | . Linux . This page covers the process of manually building TerminusDB on various Linux distributions. . Debian or Ubuntu . The following directions should work on Debian or Ubuntu. . Rust . Install Rust by following the instructions on the official Rust installation guide. . SWIPL . To use Terminus Server, you will need the SWIPL installation of Prolog. To install this in Debian variants, simply use the apt package manager: . apt install swi-prolog . Once installed, you will have to install two library dependencies from SWIPL. . This can be done by typing: . $ swipl Welcome to SWI-Prolog (threaded, 64 bits, version 8.1.10-28-g8a26a53c1) SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software. Please run ?- license. for legal details. For online help and background, visit http://www.swi-prolog.org For built-in help, use ?- help(Topic). or ?- apropos(Word). 1 ?- pack_install(terminus_store_prolog). % Contacting server .... . Terminus Server . The Terminus Server source tree should then be cloned from GitHub: . git clone https://github.com/terminusdb/terminusdb-server cd terminusdb-server . You need to set the admin user password which is used as a super-user API key for access. This can be done with the db_init script. The script should also be used to configure the server name, as shown in the example. . utils/db_init -k &quot;my_password_here&quot; -s &quot;my_server_name_here&quot; . At this point you can enter the TerminusDB directory and start the server: . ./start.pl . Now you are ready to interact with the HTTP server. . Fedora or Red Hat . These instructions have been tested on Fedora 30 and might yield different results depending on your Fedora / Red Hat release. . Rust . Install Rust by following the instructions on the official Rust installation guide. . SWIPL . SWI-Prolog is needed to run terminusdb-server. Install SWI-PROLOG with: . sudo dnf install pl pl-devel . SWIPL libraries . Run SWIPL and install the required dependencies. Note that you need to have Rust installed to compile the dependencies: . $ swipl Welcome to SWI-Prolog (threaded, 64 bits, version 8.1.10-28-g8a26a53c1) SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software. Please run ?- license. for legal details. For online help and background, visit http://www.swi-prolog.org For built-in help, use ?- help(Topic). or ?- apropos(Word). 1 ?- pack_install(terminus_store_prolog). % Contacting server .... . Terminus Server . The Terminus Server source tree should then be cloned from GitHub: . git clone https://github.com/terminusdb/terminusdb-server cd terminusdb-server . You need to set the admin user password which is used as a super-user API key for access. This can be done with the db_init script. The script should also be used to configure the server name, as shown in the example. . utils/db_init -k &quot;my_password_here&quot; -s &quot;my_server_name_here&quot; . At this point you can enter the TerminusDB directory and start the server: . ./start.pl . Now you are ready to interact with the HTTP server. . Arch Linux . Rust . Install Rust by following the instructions on the official Rust installation guide. . Library dependencies . Install all dependencies of all the required libraries: | sudo pacman -S git swi-prolog make automake autoconf libtool zlib pkgconf gcc . SWIPL libraries . Run SWIPL and install the required dependencies. Note that you need to have Rust installed to compile the dependencies: . $ swipl Welcome to SWI-Prolog (threaded, 64 bits, version 8.1.10-28-g8a26a53c1) SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software. Please run ?- license. for legal details. For online help and background, visit http://www.swi-prolog.org For built-in help, use ?- help(Topic). or ?- apropos(Word). 1 ?- pack_install(terminus_store_prolog). % Contacting server .... . Terminus Server . The Terminus Server source tree should then be cloned from GitHub: . git clone https://github.com/terminusdb/terminusdb-server cd terminusdb-server . You need to set the admin user password which is used as a super-user API key for access. This can be done with the db_init script. The script should also be used to configure the server name, as shown in the example. . utils/db_init -k &quot;my_password_here&quot; -s &quot;my_server_name_here&quot; . At this point you can enter the TerminusDB directory and start the server: . ./start.pl . Now you are ready to interact with the HTTP server. .",
    "url": "/docs/how-tos/other-install/",
    "relUrl": "/how-tos/other-install/"
  }
  ,"36": {
    "title": "WOQL Primitives",
    "content": "WOQL Primitives . WOQL primitives are WOQL.js functions which directly map onto words in the underlying JSON-LD language. All other WOQL.js functions are compound functions which translate into multiple WOQL primitives, or are helper functions which reduce the need to write verbose JSON-LD directly. . Basics . triple Status: Stable . Generates a triple pattern matching rule to match any triples that meet the constraints . Syntax . triple(Subject, Predicate, Object) . Arguments . Arguments Types Requirement . Subject | (string*) - The IRI of a triple’s subject or a variable | Mandatory | . Predicate | (string*) - The IRI of a property or a variable | Mandatory | . Object | (string*) - The IRI of a node or a variable, or a literal | Mandatory | . Returns . A WOQLQuery object containing the triple pattern matching rule . Example let [subj, obj] = vars(&quot;subj&quot;, &quot;obj&quot;) triple(s, &quot;type&quot;, o) . . quad Status: Stable . Generates a quad pattern matching rule to match any triples that meet the constraints in the specified Graph . Syntax quad(Subject, Predicate, Object, Graph) . Arguments Arguments Types Requirement . Subject | (string*) - The IRI of a triple’s subject or a variable | Mandatory | . Predicate | (string*) - The IRI of a property or a variable | Mandatory | . Object | (string*) - The IRI of a node or a variable, or a literal | Mandatory | . Graph | (string*) - The Resource String identifying the graph to be searched for the pattern | Mandatory | . Returns A WOQLQuery object containing the quad pattern matching rule . Example let [class, prop] = vars(&quot;class&quot;, &quot;prop&quot;) quad(class, &quot;domain&quot;, prop, &quot;schema/main&quot;) . . comment Status: Stable . Inserts a textual comment into a query and optionally ‘comments’ out the contained subquery . Syntax comment(Comment, Subq) . Arguments Arguments Types Requirement . Comment | (string*) - The textual comment | Mandatory | . Subq | (string*) - (WOQLQuery) - An optional enclosed sub-query that is commented out Note: Subq is an argument or a chained query | Mandatory | . Returns A WOQLQuery object containing the comment . Example comment(&quot;This has a bug&quot;).triple(a, b, c) . . select Status: Stable . Selects (filters) a list of variables from the enclosed sub-query and removes the rest . Syntax select(...Vars, Subq) . Arguments Arguments Types Requirement . …Vars | (string*) - A list of one or more variables to select | Mandatory | . Subq | (string*) - (WOQLQuery) - A query from which the variables will be filtered out Note: Subq is an argument or a chained query | Mandatory | . Returns A WOQLQuery object containing the filtered variables and subquery . Example let [grouped, subject, class] = vars(&quot;grouped&quot;, &quot;subject&quot;, &quot;class&quot;) select(grouped).group_by(subject, class, grouped).triple(subject, &quot;type&quot;, class) . . and Status: Stable . Logical conjunction of the contained queries - all queries must match or the entire clause fails . Syntax and(...Subqueries) . Arguments Arguments Types Requirement . …Subqueries | (WOQLQuery*) - A list of one or more woql queries to execute as a conjunction | Mandatory | . Returns A WOQLQuery object containing the conjunction of queries . Example let [subject, class, label] = vars(&quot;subject&quot;, &quot;class&quot;, &quot;label&quot;) and( triple(subject, &#39;type&#39;, class), triple(subject, &quot;label&quot;, label) ) . . or Status: Stable . Logical Or of the contained queries - the first subquery to match will cause subsequent subqueries to not be evaluated . Syntax or(...Subqueries) . Arguments Arguments Types Requirement . …Subqueries | (WOQLQuery*) - A list of one or more woql queries to execute as alternatives | Mandatory | . Returns A WOQLQuery object containing the logical Or of the subqueries . Example let [subject] = vars(&quot;subject&quot;) or( triple(subject, &#39;label&#39;, &quot;A&quot;), triple(subject, &quot;label&quot;, &quot;a&quot;) ) . . opt Status: Stable . Specifies that the Subquery is optional - if it does not match the query will not fail . Syntax opt(Subquery) ~ optional(Subquery) (alias)) . Arguments Arguments Types Requirement . Subquery | (WOQLQuery*) - A subquery which will be optionally matched Note: Subq is an argument or a chained query | Mandatory | . Returns A WOQLQuery object containing the optional sub Query . Example let [subject] = vars(&quot;subject&quot;) opt().triple(subject, &#39;label&#39;, &quot;A&quot;) . . not Status: Stable . Logical negation of the contained subquery - if the subquery matches, the query will fail to match . Syntax not(Subquery) . Arguments Arguments Types Requirement . Subquery | (WOQLQuery*) - A subquery which will be negated Note: Subq is an argument or a chained query | Mandatory | . Returns A WOQLQuery object containing the negated sub Query . Example let [subject, label] = vars(&quot;subject&quot;, &quot;label&quot;) not().triple(subject, &#39;label&#39;, label) . . isa Status: Stable . Tests whether a given instance IRI has type Class . Syntax isa(IRI, Class) . Arguments Arguments Types Requirement . Instance_IRI | (string*) - A string IRI or a variable | Mandatory | . Class | (string*) - A Class IRI or a variable | Mandatory | . Returns A WOQLQuery object containing the type test . Example let [subject] = vars(&quot;subject&quot;) isa(subject, &quot;Person&quot;) . . sub Status: Stable . Tests whether a given Class subsumes another class . Syntax sub(ClassA, ClassB) ~ subsumption(ClassA, ClassB) (Alias) . Arguments Arguments Types Requirement . ClassA | (string*) - A Class IRI or a variable representing the subsuming (parent) class | Mandatory | . Class | (string*) - A Class IRI or a variable representing the subsumed (child) class | Mandatory | . Returns A WOQLQuery object containing the subsumption test . Example let [class] = vars(&quot;class&quot;) sub(&quot;Vegetable&quot;, class) . . unique Status: Stable . Generate a new IRI from the prefix and a hash of the variables which will be unique for any given combination of variables . Syntax unique(Prefix, Vars, NewIRI) . Arguments Arguments Types Requirement . Prefix | (string*) - A prefix for the IRI - typically formed of the doc prefix and the classtype of the entity (“doc:Person”) | Mandatory | . Vars | ([string*]) - An array of variables and / or strings from which the unique hash will be generated | Mandatory | . NewIRI | (string*) - Variable in which the unique ID is stored | Mandatory | . Returns A WOQLQuery object containing the unique ID generating function . Example let [newid] = vars(&quot;newid&quot;) unique(&quot;doc:Person&quot;, [&quot;John&quot;, &quot;Smith&quot;], newid) . . idgen Status: Stable . Generate a new IRI from the prefix and concatention of the variables . Syntax idgen(Prefix, Vars, NewIRI) ~ idgenerator(Prefix, Vars, NewIRI) (Alias) . Arguments Arguments Types Requirement . Prefix | (string*) - A prefix for the IRI - typically formed of the doc prefix and the classtype of the entity (“doc:Person”) | Mandatory | . Vars | ([string*]) - An array of variables and / or strings from which the id will be generated | Mandatory | . NewIRI | (string*) - Variable in which the unique ID is stored | Mandatory | . Returns A WOQLQuery object containing the ID generating function . Example let [newid] = vars(&quot;newid&quot;) idgen(&quot;doc:Person&quot;, [&quot;John&quot;, &quot;Smith&quot;], newid) . . true Status: Stable . A function that always matches, always returns true . Syntax true() . Arguments None . Returns A WOQLQuery object containing the true value that will match any pattern . Example when(true()).triple(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) . . eq Status: Stable . Tests whether the two arguments are equal . Syntax eq(A, B) ~ equal(A, B) (Alias) . Arguments Arguments Types Requirement . A | ([string] or literal*) - A variable or IRI or any literal (e.g. number, string) or basic datatype | Mandatory | . B | ([string] or literal*) - A variable or IRI or any literal (e.g. number, string) or basic datatype | Mandatory | . Returns A WOQLQuery object containing the ID that matches . Example let [nid] = vars(&quot;mike&quot;) idgen(&quot;doc:mike&quot;, nid) . . start Status: Stable . Specifies an offset position in the results to start listing results from . Syntax start(Start, Subq) . Arguments Arguments Types Requirement . Start | (integer*) - A variable that refers to an interger or an integer literal (e.g. number, string) | Mandatory | . Subq | (WOQLQuery*) - An array of variables and / or strings from which the id will be generated Note: Subq is an argument or a chained query |   | . Mandatory |   |   | . Returns A WOQLQuery whose results will be returned starting from the specified offset . Example let [a, b, c] = vars(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) start(100).triple(a, b, c) . . limit Status: Stable . Specifies a maximum number of results that will be returned from the subquery . Syntax limit(Limit, Subq) . Arguments Arguments Types Requirement . Limit | (integer/string*) - A variable that refers to an non-negative integer or a non-negative integer | Mandatory | . Subq | A subquery whose results will be limited Note: Subq is an argument or a chained query | Mandatory | . Returns A WOQLQuery whose results will be returned starting from the specified offset . Example let [a, b, c] = vars(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) limit(100).triple(a, b, c) . . path Status: Stable . Performs a path regular expression match on the graph . Syntax path(Subject, Pattern, Object, Path) . Arguments Arguments Types Requirement . Subject | (string*) - An IRI or variable that refers to an IRI representing the subject, i.e. the starting point of the path | Mandatory | . Pattern | (string) - A path regular expression describing a pattern through multiple edges of the graph Path regular expressions consist of a sequence of predicates and / or a set of alternatives, with quantification operators The characters that are interpreted specially are the following: - representing alternative choices , - representing a sequence of predcitates + - Representing a quantification of 1 or more of the preceding pattern in a sequence {min, max} - Representing at least min examples and at most max examples of the preceding pattern - Representing any predicate() - Parentheses, interpreted in the normal way to group clauses | Mandatory | . Object | (string*) - An IRI or variable that refers to an IRI representing the object, i.e. ending point of the path | Mandatory | . Path | (string*) - A variable in which the actual paths traversed will be stored | Mandatory | . Returns A WOQLQuery which contains the path regular expression matching expression . Example let [person, grand_uncle, lineage] = vars(&quot;person&quot;, &quot;grand uncle&quot;, &quot;lineage&quot;) path(person, ((father|mother) {2,2}), brother), grand_uncle, lineage) . . order by Status: Stable . Orders the results of the contained subquery by a precedence list of variables . Syntax order_by(...Ordervars, Subq) . Arguments Arguments Types Requirement . Ordervars | (string*) - A sequence of variables, by which to order the results, each optionally followed by either “asc” or “desc” to represent order | Mandatory | . Subq | (WOQLQuery*) - The query whose results will be ordered Note: Subq is an argument or a chained query | Mandatory | . Returns A WOQLQuery which contains the ordering expression . Example let [person, last_name, first_name] = vars(&quot;person&quot;, &quot;last name&quot;, &quot;first name&quot;) order_by(last_name, &quot;asc&quot;, first_name, &quot;desc&quot;) .triple(person, &quot;first_name&quot;, first_name) .triple(person, &quot;last_name&quot;, last_name) . . group by Status: Stable . Groups the results of the contained subquery on the basis of identical values for Groupvars, extracts the patterns defined in PatternVars and stores the results in GroupedVar . Syntax group_by(GroupVars, PatternVars, GroupedVar, Subq) . Arguments Arguments Types Requirement . GroupVars | ([string] or string*) - Either a single variable or an array of variables | Mandatory | . PatternVars | ([string] or string*) Either a single variable or an array of variables | Mandatory | . GroupedVar | (string*) A variable | Mandatory | . Subq | (WOQLQuery*) - The query whose results will be grouped Note: Subq is an argument or a chained query | Mandatory | . Returns A WOQLQuery which contains the grouping expression . Example let [age, last_name, first_name, age_group, person] = vars(&quot;age&quot;, &quot;last name&quot;, &quot;first name&quot;, &quot;age group&quot;, &quot;person&quot;) group_by(age, [last_name, first_name], age_group) .triple(person, &quot;first_name&quot;, first_name) .triple(person, &quot;last_name&quot;, last_name) .triple(person, &quot;age&quot;, age) . . cast Status: Stable . Casts the value of Input to a new value of type Type and stores the result in CastVar . Syntax cast(Input, Type, CastVar) ~ typecast(InputVar, Type, CastVar) (Alias) . Arguments Arguments Types Requirement . Input | ([string] or literal*) - Either a single variable or a literal of any basic type | Mandatory | . Type | Type ([string] or string*) Either a variable or a basic datatype (xsd / xdd) | Mandatory | . CastVar | CastVar (string*) A variable | Mandatory | . Returns A WOQLQuery which contains the casting expression . Example let [time] = vars(&quot;time&quot;) cast(&quot;22/3/98&quot;, &quot;xsd:dateTime&quot;, time) . . List Processing . member Status: Stable . Matches if List includes Element . Syntax member(Element, List) . Arguments Arguments Types Requirement . Element | (string or literal*) - Either a variable, IRI or any simple datatype | Mandatory | . List | List ([string, literal] or string*) Either a variable representing a list or a list of variables or literals | Mandatory | . Returns A WOQLQuery which contains the List inclusion pattern matching expression . Example let [name] = vars(&quot;name&quot;) member(name, [&quot;john&quot;, &quot;joe&quot;, &quot;frank&quot;]) . . length Status: Stable . Matches or generates the length of a list . Syntax length(List, Len) . Arguments Arguments Types Requirement . List | ([string, literal] or string*) Either a variable representing a list or a list of variables or literals | Mandatory | . Len | (string or integer) A variable in which the length of the list is stored or the length of the list as a non-negative integer | Mandatory | . Returns A WOQLQuery which contains the Length pattern matching expression . Example let [count] = vars(&quot;count&quot;) length([&quot;john&quot;, &quot;joe&quot;, &quot;frank&quot;], count) . . String Processing . concat Status: Stable . Concatenates the List into a string and matches / stores the result in Concatenated . Syntax concat(List, Concatenated) . Arguments Arguments Types Requirement . List | ([string] string*) - a variable representing a list or a list of variables or strings - variables can be embedded in the string if they do not contain spaces | Mandatory | . Returns A WOQLQuery which contains the Concatenation pattern matching expression . Example let [first_name, last_name, full_name] = vars(&quot;first&quot;, &quot;last&quot;, &quot;full&quot;) concat([first_name, &quot; &quot;, last_name], full_name) . . trim Status: Stable . A trimmed version of Untrimmed (with leading and trailing whitespace removed) is stored in Trimmed . Syntax trim(Untrimmed, Trimmed) . Arguments Arguments Types Requirement . Untrimmed | (string*) - A string or variable containing the untrimmed version of the string | Mandatory | . Trimmed | (string*) - A string or variable containing the trimmed version of the string | Mandatory | . Returns A WOQLQuery which contains the Trim pattern matching expression . Example let [trimmed] = vars[&#39;trimmed&#39;] trim(&quot;hello &quot;, trimmed) //trimmed contains &quot;hello&quot; . . substr Status: Stable . Generates a Substring From String, starting from Begin offset, of length Length, with After Number of characters after the substring . Syntax substr(String, Before, Length, After, SubString) ~ substring(String, Before, Length, After, SubString) (Alias) . Arguments Arguments Types Requirement . String | (string*) - String or variable representing the full string | Mandatory | . Before | (string or integer*) Integer or variable representing the number of characters from the start to start the substring from | Mandatory | . Length | (string or integer*) Integer or variable representing the number of characters in the substring | Mandatory | . After | (string or integer*) Integer or variable representing the number of characters from the end to end the substring from | Mandatory | . SubString | (string*) - The substring matched according to the values specified in the other arguments | Mandatory | . Returns A WOQLQuery which contains the Substring pattern matching expression . Example let [trimmed] = [&#39;trimmed&#39;] substr(&quot;helloIAmTerminusDb&quot;, 8, 8, 2, ) //trimmed contains &quot;hello&quot; . . upper Status: Stable . Generates or matches an upper-case version of String in Capitalized . Syntax upper(String, Capitalized) . Arguments Arguments Types Requirement . String | ((string*) - string or variable representing the uncapitalized string | Mandatory | . Capitalized | (string*) - string or variable representing the capitalized string | Mandatory | . Returns A WOQLQuery which contains the Upper case pattern matching expression . Example let [allcaps] = vars(&quot;caps&quot;) upper(&quot;aBCe&quot;, allcaps) //upper contains &quot;ABCE&quot; . . lower Status: Stable . Generates or matches a lower-case version of String in LowerCased . Syntax lower(String, LowerCased) . Arguments Arguments Types Requirement . String | (string*) - string or variable representing the non-lowercased string | Mandatory | . LowerCased | (string*) - string or variable representing the lowercased string | Mandatory | . Returns A WOQLQuery which contains the Lower Case pattern matching expression . Example let [lower] = var(&quot;l&quot;) lower(&quot;aBCe&quot;, lower) //lower contains &quot;abce&quot; . . pad Status: Stable . Pads out the string Input to be exactly Len long by appending the Pad character the necessary number of times to form Output . Syntax pad(Input, Pad, Len, Output) . Arguments Arguments Types Requirement . Input | (string*) - The input string or variable in unpadded state | Mandatory | . Pad | (string*) - The characters to use to pad the string or a variable representing them | Mandatory | . Len | (string or integer*) - The variable or integer value representing the length of the output string | Mandatory | . Output | (string*) - The variable or string representing the padded version of the input string | Mandatory | . Returns A WOQLQuery which contains the Pad pattern matching expression . Example let [fixed] = vars(&quot;fixed length&quot;) pad(&quot;joe&quot;, &quot; &quot;, 8, fixed) //fixed contains &quot;joe &quot; . . split Status: Stable . Splits a string (Input) into a list strings (Output) by removing separator . Syntax split(Input, Separator, Output) . Arguments Arguments Types Requirement . Input | (string*) - A string or variable representing the unsplit string | Mandatory | . Separator | (string*) - A string or variable containing a sequence of charatcters to use as a separator | Mandatory | . Output | (string, [string]) - A variable representing a list, or a list of variables and / or strings | Mandatory | . Returns A WOQLQuery which contains the Split pattern matching expression . Example let [words] = vars(&quot;words&quot;) split(&quot;joe has a hat&quot;, &quot; &quot;, words) //words contains [&quot;joe&quot;, &quot;has&quot;, &quot;a&quot;, &quot;hat&quot;] . . join Status: Stable . Joins a list variable together (Input) into a string variable (Output) by glueing the strings together with Glue . Syntax join(Input, Glue, Output) . Arguments Arguments Types Requirement . Input | (string / [string]*) - a variable representing a list or a list of strings and / or variables | Mandatory | . Glue | (string*) - A variable or string representing the characters to put in between the joined strings in input | Mandatory | . Output | (string*) - A variable or string containing the output string | Mandatory | . Returns A WOQLQuery which contains the Join pattern matching expression . Example let [sentence] = vars(&quot;sentence&quot;) join([&quot;joe&quot;, &quot;has&quot;, &quot;a&quot;, &quot;hat&quot;, &quot; &quot;, sentence) //sentence contains [&quot;joe has a hat&quot;] . . re Status: Stable . Matches the regular expression defined in Patern against the Test string, to produce the matched patterns in Matches . Syntax re(Pattern, Test, Matches) ~ regexp(Pattern, Test, Matches) (Alias) . Arguments Arguments Types Requirement . Pattern | (string*) - string or variable using normal PCRE regular expression syntax with the exception that special characters have to be escaped twice (to enable transport in JSONLD) | Mandatory | . Test | (string*) - string or variable containing the string to be tested for patterns with the regex | Mandatory | . Matches | (string / [string]) - variable representing the list of matches or a list of strings or variables |   | . Mandatory |   |   | . Returns A WOQLQuery which contains the Regular Expression pattern matching expression . Example let [e, llo] = vars(&#39;e&#39;, &#39;ello&#39;) WOQL.re(&quot;h(.).*&quot;, &quot;hello&quot;, [e, llo]) //e contains &#39;e&#39;, llo contains &#39;llo&#39; . . like Status: Stable . Generates a string Leverstein distance measure between StringA and StringB . Syntax like(StringA, StringB, Distance) . Arguments Arguments Types Requirement . StringA | (string*) - string literal or variable representing a string to be compared | Mandatory | . StringA | (string*) - string literal or variable representing the other string to be compared | Mandatory | . Distance | (string / [float]*) - variable representing the distance between the variables |   | . Mandatory |   |   | . Returns A WOQLQuery which contains the Like pattern matching expression . Example let [dist] = vars(&#39;dist&#39;) like(&quot;hello&quot;, &quot;hallo&quot;, dist) //dist contains 0.7265420560747664 . . Updates / Transactions . add triple Status: Stable . Adds a single triple to the database . Syntax add_triple(Subject, Predicate, Object) . Arguments Arguments Types Requirement . Subject | (string*) - The IRI of a triple’s subject or a variable | Mandatory | . Predicate | (string*) - The IRI of a property or a variable | Mandatory | . Object | (string*) - The IRI of a node or a variable, or a literal | Mandatory | . Returns A WOQLQuery which contains the add_triple insert statement . Example add_triple(&quot;john&quot;, &quot;age&quot;, 42) . . add quad Status: Stable . Adds a single triple to the specified graph in the database . Syntax add_quad(Subject, Predicate, Object, Graph) . Arguments Arguments Types Requirement . Subject | (string*) - The IRI of a triple’s subject or a variable | Mandatory | . Predicate | (string*) - The IRI of a property or a variable | Mandatory | . Object | (string*) - The IRI of a node or a variable, or a literal | Mandatory | . Graph | (string*) - The resource identifier of a graph | Mandatory | . Returns A WOQLQuery which contains the add_quad insert statement . Example add_quad(&quot;Person&quot;, &quot;type&quot;, &quot;owl:Class&quot;, &quot;schema/main&quot;) . . delete triple Status: Stable . Deletes a single triple from the default graph of the database . Syntax delete_triple(Subject, Predicate, Object) . Arguments Arguments Types Requirement . Subject | (string*) - The IRI of a triple’s subject or a variable | Mandatory | . Predicate | (string*) - The IRI of a property or a variable | Mandatory | . Object | (string*) - The IRI of a node or a variable, or a literal | Mandatory | . Returns A WOQLQuery which contains the Triple Deletion statement . Example delete_triple(&quot;john&quot;, &quot;age&quot;, 42) . . delete quad Status: Stable . Deletes a single triple from the default graph of the database . Syntax delete_quad(Subject, Predicate, Object, Graph) . Arguments Arguments Types Requirement . Subject | (string*) - The IRI of a triple’s subject or a variable | Mandatory | . Predicate | (string*) - The IRI of a property or a variable | Mandatory | . Object | (string*) - The IRI of a node or a variable, or a literal | Mandatory | . Graph | (string*) - The resource identifier of a graph | Mandatory | . Returns A WOQLQuery which contains the Delete Quad Statement . Example delete_quad(&quot;Person&quot;, &quot;type&quot;, &quot;owl:Class&quot;, &quot;schema/main&quot;) . . when Status: Stable . Generates a transaction which encompasses all situations in which the Condition is true, the Consequent will be executed - the when block encapsulates a single transaction and allows a single query to express multiple transactions (by including multiple when blocks) . Syntax when(Condition, Consequent) . Arguments Arguments Types Requirement . Condition | (WOQLQuery*) - The query which, for each match, will cause the associated consequent to execute | Mandatory | . Consequent | (WOQLQuery*) - The query which, for each match of the Condition, will be executed | Mandatory | . Returns A WOQLQuery which contains the conditional transactional statement . Example when(true).add_triple(&quot;doc:john&quot;, &quot;type&quot;, &quot;scm:Person&quot;) . . Arithmetic Operators . Arithmetic Operators can be arbitrarily composed through the construction of Arithmetic Expressions and passed to the eval function which returns a variable containing the calculated result. This provides a general, stand-alone scientific calculator function, into which variables and constants from larger queries can be injected into mathematical functions. Used in isolation it is a calculator. . evaluate Status: Stable . Evaluates the passed arithmetic expression and generates or matches the result value . Syntax evaluate(ArithmeticExpression, Result) ~ eval(ArithmeticExpression, Result) . (note eval does not work without a preceding WOQL. you must use evaluate to avoid clashing with javascripts eval() function) &lt;/div&gt; . Arguments Arguments Types Requirement . ArithmeticExpression | (WOQLQuery*) - A WOQL query containing a valid WOQL Arithmetic Expression, which is evaluated by the function | Mandatory | . Result | (string or decimal or integer*) - Either a variable, in which the result of the expression will be stored, or a numeric literal which will be used as a test of result of the evaluated expression | Mandatory | . Returns A WOQLQuery which contains the Arithmetic function . Example let [result] = vars(&quot;result&quot;) evaluate(plus(2, minus(3, 1)), result) . . sum Status: Stable . computes the sum of the List of values passed. In contrast to other arithmetic functions, sum self-evaluates - it does not have to be passed to evaluate() . Syntax sum(List, Total) . Arguments Arguments Types Requirement . List | (WOQLQuery) - ([string or numeric]) - a list variable, or a list of variables or numeric literals | Mandatory | . Total | a variable or numeric containing the sum of the values in List | Mandatory | . Returns A WOQLQuery which contains the Sum expression . Example let [result] = vars(&quot;result&quot;) sum([2, 3, 4, 5], result) //result contains 14 . . plus Status: Stable . adds two numbers together . Syntax plus(Number1, Number2) . Arguments Arguments Types Requirement . Number1 | (string or numeric*) - a variable or numeric containing the first value to add | Mandatory | . Number2 | (string or numeric*) - a variable or numeric containing the second value to add | Mandatory | . Returns A WOQLQuery which contains the addition expression . Example let [result] = vars(&quot;result&quot;) evaluate(plus(2, plus(3, 1)), result) //result contains 6 . . minus Status: Stable . Subtracts Number2 from Number1 . Syntax minus(Number1, Number2) . Arguments Arguments Types Requirement . Number1 | (string or numeric*) - a variable or numeric containing the value that will be subtracted from | Mandatory | . Number2 | (string or numeric*) - a variable or numeric containing the value to be subtracted | Mandatory | . Returns A WOQLQuery which contains the subtraction expression . Example let [result] = vars(&quot;result&quot;) evaluate(minus(2.1, plus(0.2, 1)), result) //result contains 0.9000000000000001 - note floating point inaccuracy . . times Status: Stable . Multiples Number1 and Number2 . Syntax times(Number1, Number2) . Arguments Arguments Types Requirement . Number1 | (string or numeric*) - a variable or numeric containing the first value to multiply | Mandatory | . Number2 | (string or numeric*) - a variable or numeric containing the second value to multiply | Mandatory | . Returns A WOQLQuery which contains the multiplication expression . Example let [result] = vars(&quot;result&quot;) evaluate(times(10, minus(2.1, plus(0.2, 1))), result) //result contains 9.000000000000002y . . divide Status: Stable . Dvides Number1 by Number2 . Syntax divide(Number1, Number2) . Arguments Arguments Types Requirement . Number1 | (string or numeric*) - a variable or numeric containing the number to be divided | Mandatory | . Number2 | (string or numeric*) - a variable or numeric containing the divisor | Mandatory | . Returns A WOQLQuery which contains the division expression . Example let [result] = vars(&quot;result&quot;) evaluate(divide(times(10, minus(2.1, plus(0.2, 1))), 10), result) //result contains 0.9000000000000001 . . floor Status: Stable . Generates the nearest lower integer to the passed number . Syntax floor(Number1) . Arguments Arguments Types Requirement . Number1 | (string or numeric*) - a variable or numeric containing the number to be floored | Mandatory | . Returns A WOQLQuery which contains the floor expression . Example let [result] = vars(&quot;result&quot;) evaluate(divide(floor(times(10, minus(2.1, plus(0.2, 1)))), 10), result) //result contains 0.9 - floating point error removed . . div Status: Stable . Integer division: divides Number1 by Number2 to return an integer value . Syntax div(Number1, Number2) . Arguments Arguments Types Requirement . Number1 | (string or numeric*) - a variable or numeric containing the number to be divided | Mandatory | . Number2 | (string or numeric*) - a variable or numeric containing the divisor | Mandatory | . Returns A WOQLQuery which contains the integer division expression . Example let [result] = vars(&quot;result&quot;) evaluate(div(10, 3), result) //result contains 3 . . exp Status: Stable . Exponent - raises Number1 to the power of Number2 . Syntax exp(Number1, Number2) . Arguments Arguments Types Requirement . Number1 | (string or numeric*) - a variable or numeric containing the number to be raised to the power of the second number | Mandatory | . Number2 | (string or numeric*) - a variable or numeric containing the exponent | Mandatory | . Returns A WOQLQuery which contains the exponent expression . Example let [result] = vars(&quot;result&quot;) evaluate(exp(3, 2), result) //result contains 9 . . less Status: Stable . Matches when Val1 is less than Val2 . Syntax less(Val1, Val2) . Arguments Arguments Types Requirement . Number1 | (string or numeric*) - a variable or numeric containing the number to be compared | Mandatory | . Number2 | (string or numeric*) - a variable or numeric containing the second comporator | Mandatory | . Returns A WOQLQuery which contains the comparison expression . Example let [result] = vars(&quot;result&quot;) less(1, 1.1).eq(result, literal(true, &quot;boolean&quot;)) //result contains true . . greater Status: Stable . Matches when Val1 is greater than Val2 . Syntax greater(Val1, Val2) . Arguments Arguments Types Requirement . Val1 | (string or numeric*) - a variable or numeric containing the number to be compared | Mandatory | . Val2 | (string or numeric*) - a variable or numeric containing the second comporator | Mandatory | . Returns A WOQLQuery which contains the comparison expression . Example let [result] = vars(&quot;result&quot;) greater(1.2, 1.1).eq(result, literal(true, &quot;boolean&quot;)) //result contains true . . Importing &amp; Exporting . get Status: Stable . Retrieves the exernal resource defined by QueryResource and copies values from it into variables defined in AsVars . Syntax get(AsVArs, QueryResource) . Arguments Arguments Types Requirement . AsVArs | ([string]*) an array of AsVar variable mappings (see as for format below) | Mandatory | . QueryResource | (string*) an external resource (remote, file, post) to query | Mandatory | . Returns A WOQLQuery which contains the get expression . Example let [a, b] = vars(&quot;a&quot;, &quot;b&quot;) get(as(&quot;a&quot;, a).as(&quot;b&quot;, b)).remote(&quot;http://my.url.com/x.csv&quot;) //copies the values from column headed &quot;a&quot; into a variable a and from column &quot;b&quot; into a variable b from remote CSV . . put Status: Stable . Outputs the results of a query to a file . Syntax put(AsVArs, Subq, FileResource) . Arguments Arguments Types Requirement . AsVArs | ([string]*) an array of AsVar variable mappings (see as for format below) | Mandatory | . Subq | (WOQLQuery*) - The query which will be executed to produce the results Note: Subq is an argument or a chained query | Mandatory | . FileResource | (string*) an file resource local to the server | Mandatory | . Returns A WOQLQuery which contains the put expression . Example let [s, p, o] = vars(&quot;Subject&quot;, &quot;Predicate&quot;, &quot;Object&quot;) put(as(&quot;s&quot;, s).as(&quot;p&quot;, p).as(&quot;o&quot;, o), all()) .file(&quot;/app/local_files/dump.csv&quot;) . . as Status: Stable . Maps data from an imported source to a WOQL variable and optionally sets its type . Syntax as(SourceLocator, VarName, Type) . Arguments Arguments Types Requirement . SourceLocator | (string) - an optional string containing the CSV column header, or a variable containing the string (if it is omitted when extracting data from a CSV, the CSV will be indexed by column number) | Mandatory | . VarName | (string*) - the name of the variable into which the data from the external resource will be copied | Mandatory | . Type | (string) - an optional type to which the data will be automatically mapped on import | Optional | . Returns A WOQLQuery which contains the variable mapping expression . Example let [date] = vars(&quot;Date&quot;) get(as(&quot;Date.From&quot;, date)) .remote(&quot;http://seshatdatabank.info/wp-content/uploads/2020/01/Iron-Updated.csv&quot;) . . remote Status: Stable . Identifies a remote resource by URL and specifies the format of the resource through the options . Syntax remote(URL, Opts) . Arguments Arguments Types Requirement . URL | (string*) The URL at which the remote resource can be accessed | Mandatory | . Opts | (object) A option json which can have the following keys: type: csv/turtle | Optional | . Returns A WOQLQuery which contains the remote resource identifier . Example remote(&quot;http://url.of.resource&quot;, {type: &quot;csv&quot;}) . . file Status: Stable . Identifies a file resource as a path on the server and specifies the format through the options . Syntax file(Path, Opts) . Arguments Arguments Types Requirement . Path | (string*) The Path on the server at which the file resource can be accessed | Mandatory | . Opts | (object) A option json which can have the following keys: type: csv/turtle | Optional | . Returns A WOQLQuery which contains the file resource identifier . Example file(&quot;/path/to/file&quot;, {type: &#39;turtle&#39;} ) . . post Status: Stable . Identifies a resource as a local path on the client, to be sent to the server through a HTTP POST request, with the format defined through the options . Syntax post(Path, opts) . Arguments Arguments Types Requirement . Path | (string*) The Path on the server at which the file resource can be accessed | Mandatory | . Opts | (object) A option json which can have the following keys: type: csv/turtle | Optional | . Returns A WOQLQuery which contains the Post resource identifier . Example post(&quot;/.../.../&quot;, {}) . . Resource Specification . using Status: Stable . Specifies the resource to use as default in the contained query . Syntax using(GraphResource, Subq) . Arguments Arguments Types Requirement . GraphResource | (string*) - A valid graph resource identifier string | Mandatory | . Subq | The query which will be executed against the resource identified above Note: Subq is an argument or a chained query | Mandatory | . Returns A WOQLQuery which is defined to run against the resource . Example using(&quot;admin/minecraft&quot;).all() //retrieves all triples in the minecraft db of the admin organization . . into Status: Stable . Specifies the graph resource to write the contained query into . Syntax into(GraphResource, Subq) . Arguments Arguments Types Requirement . GraphResource | (string*) - A valid graph resource identifier string | Mandatory | . Subq | The query which will be written into the graph Note: Subq is an argument or a chained query | Mandatory | . Returns A WOQLQuery which will be written into the graph in question . Example using(&quot;admin/minecraft&quot;).into(&quot;instance/main&quot;).add_triple(&quot;a&quot;, &quot;type&quot;, &quot;scm:X&quot;) //writes a single tripe (doc:a, rdf:type, scm:X) into the main instance graph . . Database Size . size Status: Stable . Calculates the size in bytes of the contents of the resource identified in ResourceID . Syntax size(ResourceID, Size) . Arguments Arguments Types Requirement . ResourceID | (string*) - A valid resource identifier string (can refer to any graph / branch / commit / db) | Mandatory | . Size | (string or integer*) - An integer literal with the size in bytes or a variable containing that integer | Mandatory | . Returns A WOQLQuery which contains the size expression . Example let [sz] = vars(&quot;s&quot;) size(&quot;admin/minecraft/local/branch/main/instance/main&quot;, sz) //returns the number of bytes in the main instance graph on the main branch . . triple count Status: Stable . Calculates the size in bytes of the contents of the resource identified in ResourceID . Syntax triple_count(ResourceID, Count) . Arguments Arguments Types Requirement . ResourceID | (string*) - A valid resource identifier string (can refer to any graph / branch / commit / db) | Mandatory | . Count | (string or integer*) - An integer literal with the size in bytes or a variable containing that integer | Mandatory | . Returns A WOQLQuery which contains the size expression . Example let [tc] = vars(&quot;s&quot;) triple_count(&quot;admin/minecraft/local/_commits&quot;, tc) //returns the number of bytes in the local commit graph . . Document Queries (Experimental / Unstable) . Document queries take or return entire JSON-LD document as arguments. This relies upon the internal frame-generation capabilities of the database and requires the user to have defined discrete document classes to dictate at what points the graph traversal is truncated - a document is considered to contain all objects within it, with the exception of predicates and classes that belong to other documents. This takes some care - improperly defined it can lead to very slow queries which contain the whole database unrolled into a single document - not normally what we require. . update object Status: Experimental / Unstable . Updates a document (or any object) in the db with the passed json-ld - replaces the current version . Syntax update_object(JSONLD) . Arguments Arguments Types Requirement . JSONLD | (string*) the document’s JSON-LD form which will be written to the DB | Mandatory | . Returns A WOQLQuery which contains the update object expression . Example update_object({ &quot;@id&quot;: &quot;doc:joe&quot;, &quot;@type&quot;: &quot;scm:Person&quot;, &quot;rdfs:label&quot;: { &quot;@type&quot;: &quot;xsd:string&quot;, &quot;@value&quot;: &quot;Joe&quot; } }) . . delete object Status: Stable . Deletes the entire refered document and all references to it . Syntax delete_object(JSON_or_IRI) . Arguments Arguments Types Requirement . JSON_or_IRI | (string*) either a full JSON-LD document, an IRI literal or a variable containing either | Mandatory | . Returns A WOQLQuery which object deletion expression . Example delete_object(&quot;doc:mydoc&quot;) . . read object Status: Experimental / Unstable . Saves the entire document with IRI DocumentIRI into the JSONLD variable . Syntax read_object(DocumentIRI, JSONLD) . Arguments Arguments Types Requirement . DocumentIRI | (string*) either an IRI literal or a variable containing an IRI | Mandatory | . JSONLD | (string*) a variable into which the document’s JSON-LD form will be saved | Mandatory | . Returns A WOQLQuery which contains the document retrieval expression . Example let [mydoc] = vars(&quot;mydoc&quot;) read_object(&quot;doc:a&quot;, mydoc) //mydoc will have the json-ld document with ID doc:x stored in it . .",
    "url": "/docs/reference/woql/primitives",
    "relUrl": "/reference/woql/primitives"
  }
  ,"37": {
    "title": "Pushing and Pulling Changes",
    "content": "Pushing and Pulling Changes . Sharing databases and updates to databases is easy with TerminusDB and TerminusHub. We call this pulling and pushing changes: you pull updates from TerminusHub to your local version and push changes from your local version to TerminusHub. This makes collaboration and synchronization easy. . This short tutorial shows you how to push and pull using the TerminusDB console. We have installed using bootstrap. . . Step 1 - Create a DB, Build a Schema . First things first, login to TerminusHub and click ‘create’. . . Ok, so we are going to create the database on TerminusHub so we can give access to our collaborators and colleagues. Let’s call the database team and give the ID team_list. You can also choose a ‘team’ appropriate image to associate with the database. We have added the description this is a list of team members. . . Once you have created the database on TerminusHub, you will be taken to the DB Home screen. The first thing we need to do is create a simple schema, so click on ‘query’ and enter the following script: . WOQL.doctype(&quot;TeamMember&quot;).label(&quot;Team Member&quot;) .property(&quot;owner&quot;,&quot;xsd:string&quot;) .label(&quot;owner&quot;) . That’ll look like this in the console: . . Now lets just quickly insert some test data. Let’s use Mike and Sakura as our team members. . Insert Mike on the query page and press ‘Run Query’: . WOQL.and( WOQL.add_triple(&quot;doc:mike&quot;, &quot;type&quot;, &quot;scm:TeamMember&quot;), WOQL.add_triple(&quot;doc:mike&quot;, &quot;owner&quot;, &quot;mike&quot;) ) . Insert Mike on the query page and press ‘Run Query’: . WOQL.and( WOQL.add_triple(&quot;doc:sakura&quot;, &quot;type&quot;, &quot;scm:TeamMember&quot;), WOQL.add_triple(&quot;doc:sakura&quot;, &quot;owner&quot;, &quot;sakura&quot;) ) . Now we have team members, we can go to the DB Home pane and see the updates (we used commit messages ‘Insert Mike’ and ‘Insert Sakura’): . . . Step 2 - Push the Database to Hub . We now have a database with a schema and some data. Let’s share it with another user. Click on the ‘Synchronize’ tab and under ‘Upload’ click the ‘Push’ button to share the database on TerminusHub. Once you have pushed you will see a report letting you know that the action was successful. . . Once you have pushed to Hub, you should click on the TerminusDB logo to go back to the home screen and click on ‘Collaborate’. Use the drop-down menu on the right to select ‘Add Collaborators’. You can then select the database you want to share - in this case, ‘team’ - and give the correct permission. You can give read, write or manage rights to a collaborator. You should then include the ID or email of your collaborator and include an introduction note. (Note, if there is more than one, you can separate the ids or emails with a comma). . . Go ahead and press ‘Add Collaborators’. . That is it - you have pushed the database to Hub and added a collaborator who can now pull updates from TerminusHub. . . Step 3 - Pull from Hub . We are now in the account we shared with and can see all of the changes that we made: . . We can now add more information and the commit history is updated with the new person making the commit: . . These changes can be pushed back to TerminusHub, so collaborators can collectively work on shared databases. . . Of course, the complexity of collaboration can increase to match your workload! Trying branching first, then pushing the branch and have your collaborator pull that branch. .",
    "url": "/docs/tutorials/push-pull-tutorial/",
    "relUrl": "/tutorials/push-pull-tutorial/"
  }
  ,"38": {
    "title": "Python Client",
    "content": "Python Client . Please visit the client documentation site for the reference: . Python Client .",
    "url": "/docs/reference/python-client/",
    "relUrl": "/reference/python-client/"
  }
  ,"39": {
    "title": "WOQL Query Guide in Python",
    "content": "WOQL Query Guide in Python . . Get an Edge | Connect the dots | Paths | Updates and Inserts | Casting | String Matching | String manipulation | Mathematics | Conclusion | . Get an Edge . TerminusDB is a graph database, so we represent all data as edges. An edge is either a link from one node to another or a link from a node to some data. . In order to query data, we need to first have some data to query. You can get a fairly big database by running the following database by cloning using the following script (Note: this might take a few minutes as DBPedia is quite large!) . from terminusdb_client import WOQLClient from terminusdb_client import WOQLQuery as WQ server_url = &quot;https://127.0.0.1:6363&quot; db = &quot;dbpedia&quot; user = &quot;admin&quot; account = &quot;admin&quot; key = &quot;root&quot; remote_database = &quot;https://hub.terminusdb.com/gavin/dbpedia&quot; client = WOQLClient(server_url) client.connect(user=user, account=account, key=key, db=db) new_db = &quot;dbpedia_copy&quot; client.remote_auth({ &quot;type&quot; : &quot;basic&quot;, &quot;user&quot; : user, &quot;key&quot; : key}) client.clonedb({ &quot;remote_url&quot; : f&quot;{remote_database}&quot;, &quot;comment&quot; : &quot;DBpedia&quot;, &quot;label&quot; : &quot;DBpedia&quot;}, new_db) . If you’ve managed to get this downloaded, you can use the same client for the remaining queries. . In the python SDK, you can get a single edge as follows: . result = WQ().limit(4).triple(&quot;v:X&quot;, &quot;v:P&quot;, &quot;v:Y&quot;).execute(client) . This query asks for every edge in the graph, limiting to the first 10 results. . The v: means that X, P, and Y are considered to be variables. . As it turns out, the first results are edges that have to do with the American punk band “chk-chk-chk” (or !!!). . The result of the query is the following typical binding return form: . {&#39;@type&#39;: &#39;api:WoqlResponse&#39;, &#39;api:status&#39;: &#39;api:success&#39;, &#39;api:variable_names&#39;: [&#39;X&#39;, &#39;P&#39;, &#39;Y&#39;], &#39;bindings&#39;: [{&#39;P&#39;: &#39;http://dbpedia.org/ontology/activeYearsStartYear&#39;, &#39;X&#39;: &#39;http://dbpedia.org/resource/!!!&#39;, &#39;Y&#39;: {&#39;@type&#39;: &#39;http://www.w3.org/2001/XMLSchema#gYear&#39;, &#39;@value&#39;: &#39;1996&#39;}}, {&#39;P&#39;: &#39;http://dbpedia.org/ontology/alias&#39;, &#39;X&#39;: &#39;http://dbpedia.org/resource/!!!&#39;, &#39;Y&#39;: {&#39;@language&#39;: &#39;en&#39;, &#39;@value&#39;: &#39;Chk Chk Chk&#39;}}, {&#39;P&#39;: &#39;http://dbpedia.org/ontology/associatedBand&#39;, &#39;X&#39;: &#39;http://dbpedia.org/resource/!!!&#39;, &#39;Y&#39;: &#39;http://dbpedia.org/resource/Maserati_(band)&#39;}, {&#39;P&#39;: &#39;http://dbpedia.org/ontology/associatedBand&#39;, &#39;X&#39;: &#39;http://dbpedia.org/resource/!!!&#39;, &#39;Y&#39;: &#39;http://dbpedia.org/resource/Out_Hud&#39;}], &#39;deletes&#39;: 0, &#39;inserts&#39;: 0, &#39;transaction_retry_count&#39;: 0} . This object has a number of features. The first is the @type which states that this is the result of a WOQL query. The second is that it was successful (rather than an error). . The third field is where it starts to get interesting. Here we have the variables which were bound in the query. These variables are in-order, in a way that can be fixed with the WQ().select call or simply by the in-order use in the query. . The next field is the most important. The bindings hold the variable values for each solution to the query. If you are familiar with SQL you can think of this as the rows of the query solution. . Finally you find deletes, inserts and transaction_retry_count, all of which have to do with updates to the graph. . The bindings are of two different types. Those that end with a node and those that end with a literal. Nodes are represented by URIs, such as the final result: &#39;http://dbpedia.org/resource/Out_Hud&#39;. Values are represented by a dictionary that gives the type as @type and the value as @value. . Connect the dots . Nodes can appear at either the beginning of an edge, or at the end of an edge. We can chain such edges together as follows: . result2 = WQ().limit(1).woql_and( WQ().triple(&quot;v:Original_Band&quot;,&quot;scm:associatedBand&quot;,&quot;v:Associated_Band&quot;), WQ().triple(&quot;v:Associated_Band&quot;,&quot;scm:associatedBand&quot;,&quot;v:Two_Hop_Band&quot;) ).execute(client) . This query finds the first result of an associated band that also has an associated band. This kind of query is where graph-databases really shine - the multihop query. We say that we want to follow one edge, and then the next by reusing the variable name &quot;v:Associated_Band&quot; twice. . Visually you might think of this as: . &quot;V:Original_Band&quot; - &quot;scm:associatedBand&quot;-&gt; &quot;v:Associated_Band&quot; -scm:associatedBand&quot;-&gt; &quot;v:Two_Hop_Band&quot; . We say that the two &quot;v:Associated_Band&quot; variables unify. That is, we treat the variables as the same element in every solution whenever the same variable is used repeatedly. . But if you look at the results, you’ll see that we’ve actually just gone and found !!! again. This isn’t surprising since one would expect the notion of an “associated” band to be reflexive. Two different variables are not required to have different values. . We can specify that we don’t want to see the same value in the two different variables with the following query: . result2 = WQ().limit(1).woql_and( WQ().triple(&quot;v:Original_Band&quot;,&quot;scm:associatedBand&quot;,&quot;v:Associated_Band&quot;), WQ().triple(&quot;v:Associated_Band&quot;,&quot;scm:associatedBand&quot;,&quot;v:Two_Hop_Band&quot;), WQ().woql_not().eq(&quot;v:Two_Hop_Band&quot;, &quot;v:Original_Band&quot;) ).execute(client) . This query asks for any two-hop-band which isn’t the original band. . Now the result for our &quot;v:Two_Hop_Band&quot; is &#39;http://dbpedia.org/resource/Headlights_(band)&#39; which is a less degenerate answer. . Paths . The above approach allows us to make arbitrary graph shapes by simply naming various nodes of the graph with the same variable. However, we can only specify shapes which we know completely. . What if we want to answer a general question, such as, what bands can I reach in N hops. We could of course make a separate query for each of the N hop solutions, but more convenient is to use a path query. . result3 = WQ().limit(2).path( &quot;v:Original_Band&quot;, &quot;scm:associatedBand+&quot;, &quot;v:Final_Band&quot;, &quot;v:Path&quot; ).execute(client) . This query will bind Original_Band and Final_Band to any bands that are connected by any number of hops on scm:associateBand, greater than 1. We follow a syntax which should be familiar to anyone who has used regular expressions, and which includes grouping: (my_pattern), wildcards: foo* or foo+ and disjunction foo|bar. . The path query also stores the result of the path in Path, the final argument. This allows you not only to know that the nodes are connected, but how they are connect. . Updates and Inserts . No database query language is complete without the ability to change the stored data. You can add yourself to the DBpedia database with a query similar to the following: . WQ().add_triple(&quot;doc:joe_murphy&quot;, &quot;scm:name&quot;, &quot;Joe Murphy&quot;).execute(client) . This will create a resource on the default prefix base with the default schema predicate named name, and having the concrete string value “Joe Murphy”. . But if you don’t want it to be there anymore, you can remove it. . WQ().delete_triple(&quot;doc:joe_murphy&quot;, &quot;scm:name&quot;, &quot;Joe Murphy&quot;).execute(client) . And if you added &quot;doc:joe_murphy&quot; and couldn’t remember what name he had, you could delete it as follows: . WQ().woql_and( WQ().triple(&quot;doc:joe_murphy&quot;, &quot;scm:name&quot;, &quot;v:X&quot;), WQ().delete_triple(&quot;doc:joe_murphy&quot;, &quot;scm:name&quot;, &quot;v:X&quot;) ).execute(client) . You can in fact search for arbitrary bindings, and delete or insert based on them. . Casting . Sometimes a thing is not the type you want it to be. In certain cases we can cast data between the various types so we can get the object we want. . For instance, if we have a string and want a date, we can put it in ISO format and make a cast: . WQ().typecast(&quot;2020-12-24T00:00:00&quot;, &quot;xsd:dateTime&quot;, &quot;v:Date&quot;).execute(client) . If the typecast is impossible, the query will fail with error (of type vio:ViolationWithDatatypeObject). You can see with the result with the following: . WQ().typecast(&quot;20-12-24T00:00:00&quot;, &quot;xsd:dateTime&quot;, &quot;v:Date&quot;).execute(client) . String Matching . The python SDK for WOQL allows basical string matching as well. You can search for an object which has a property with a given string as follows: . WQ().limit(1).woql_and( WQ().triple(&quot;v:X&quot;, &quot;scm:name&quot;, &quot;v:Y&quot;), WQ().re(&quot;.*cholera.*&quot;, &quot;v:Y&quot;, [&quot;v:All&quot;]) ).execute(client) . This will let you search for an arbitrary regexp in the last value of a string. In the DBpedia dataset, this gives you back the node: http://dbpedia.org/resource/1817–1824_cholera_pandemic which you can then investigate further. . You can use arbitrary regular expressions and the matching groups will be bound to the variables in the final list of re. . String manipulation . But we might not have the data in a format that we can cast yet. Supposing we are given the date in a different order and extracted from slightly messy text. We’ll set this situation by binding &quot;v:Date_String&quot; to &quot; 12-24-2004 &quot;. . WQ().woql_and( WQ().eq(&quot;v:Date_String&quot;, &quot; 12-24-2004 &quot;), WQ().trim(&quot;v:Date_String&quot;, &quot;v:Date_String_Trimmed&quot;), WQ().re(&quot;( d d)-( d d)-( d d d d)&quot;, &quot;v:Date_String_Trimmed&quot;, [&quot;v:All&quot;, &quot;v:Month&quot;, &quot;v:Day&quot;, &quot;v:Year&quot;]), WQ().concat([&quot;v:Year&quot;, &quot;-&quot;, &quot;v:Month&quot;, &quot;-&quot;, &quot;v:Day&quot;], &quot;v:YMD&quot;), WQ().concat([&#39;v:YMD&#39;, &#39;T00:00:00&#39;], &quot;v:ISO&quot;), WQ().typecast(&quot;v:ISO&quot;, &quot;xsd:dateTime&quot;, &quot;v:Date&quot;) ).execute(client) . Now those of us who like to have their days and months in a sensible order (like the computer does) can read the date! . Mathematics . You can also do basic mathematical manipulations. . WQ().eval(WQ().plus(1,2), &quot;v:X&quot;).execute(client) . This binds “v:X” to the result of the addition of 1 and 2. You can use variables in place of 1 and 2 and re-use &quot;v:X&quot; in later queries. For instance we could write: . WQ().woql_and( WQ().eval(WQ().times(3,2), &quot;v:Product&quot;), WQ().eval(WQ().div(&quot;v:Product&quot;,2), &quot;v:Result&quot;) ).execute(client), . Here of course we get back the number 3 as we’d expect. The complete definition of mathematical operators is in the python-client reference documentation. . Conclusion . With this bag of tricks, you should be able to wrangle more data into a form you want for data-curation tasks before running analysis, machine-learning or simply browsing over your information. .",
    "url": "/docs/how-tos/python/query-guide-python/",
    "relUrl": "/how-tos/python/query-guide-python/"
  }
  ,"40": {
    "title": "Querying",
    "content": "Querying . Introduction . While WOQL is a very powerful and sophisticated query language that allows you to concisely express very complex patterns over arbitrary data structures, what really makes it so expressive and easy to use is the radical simplicity of the core underlying concepts. . To unleash the power of WOQL, you just need to understand two very simple things. . Rule 1. Triples all the way down . In TerminusDB every single fragment of information is always and universally stored and accessible as triples. Triples are the universal and fundamental atom of information in TerminusDB - objects and documents and everything else are stored as collections of triples and it is always possible to break any object down in a reliable and deterministic way into a precise set of triples. Not only that, TerminusDB also adheres to the RDF standard, which means all triples have a regular structure and interpretation and strong norms. From a query writer point of view, this regularity is very helpful - you don’t have to care about the low-level structure of the data (what table it is stored in, how many columns there are, etc.), you just have to care about the patterns of meaning you are interested in. . A triple is just a data structure with three slots in which we can put values. Each row in the table below shows a different view of what each of the three slots means . Three is the Magic Number - Understanding Triples . Form | Triple Slot 1 | Triple Slot 2 | Triple Slot 3 | . Terminus DB Terminology | Object ID | Property | Value | . Triple Example 1 | joe | date_born | 1/2/34 | . Example 1 Interpretation | The record with ID joe | has a property called date_born | with Value 1/2/34 | . Triple Example 2 | joe | parent | mary | . Example 2 Interpretation | The record with ID joe | has a property named parent | with Value mary | . Every triple with the same ID is interpreted as being about the same thing. So if we add triples with different properties to our database which have the same IDs, they will be interpreted as representing different properties of the same thing. That’s how we build up information about things - just add properties to the appropriate record ID. The magic of triples is that the Value of a triple can be another record ID (as in the joe mother mary example) - IDs can appear in either the first or the third slot of the triple. . Writing the above examples into TerminusDB with WOQL . WOQL.add_triple(&#39;joe&#39;, &#39;date_born&#39;, &#39;1/2/34&#39;) .add_triple(&#39;joe&#39;, &#39;parent&#39;, &#39;mary&#39;) . Rule 2 Unify All The Things . The second fundamental concept behind WOQL is unification. This is an old computer science concept that has been polished and refined for 60 years and is defined in obscure mathematical jargon, but it is remarkably simple and intuitive to understand by example. . WOQL Variables . In WOQL we have the concept of variables, which are normally represented by a string that starts with v: - we use them to store the results of queries. For example, we might define variables like v:First Name , v:Family Name, v:Date of Birth for a query to find somebody’s basic identifying information. . If we use a variable in a triple query, TerminusDB will show us every possible value that exists in the database that could possibly fill that variable in that position in the query. . Single Variable Triple Pattern Examples . Putting a variable in the first slot of the triple will find the IDs of all the Objects that have a specific property set to the specified value . WOQL.triple(&#39;v:Person ID&#39;, &#39;date_born&#39;, &#39;1/2/34&#39;) . Putting a variable in the second slot will find the names of all the properties that the specified object has which have that value . // returns list of all the properties of joe that have a value equal to 10 WOQL.triple(&#39;joe&#39;, &#39;v:Property List&#39;, 10) . Putting a variable in the third slot will find the value(s) of the specified property for the specified object ID: . WOQL.triple(&#39;joe&#39;, &#39;parent&#39;, &quot;v:Joes Parents&quot;) . Two-Variable Triple Pattern Examples . Putting a variable in the first two slots of the triple will find all object IDs and properties in the database that have the specified value . //list of all objects and property names that have the value 10 WOQL.triple(&#39;v:Object ID&#39;, &#39;v:Properties&#39;, 10) . Putting variables in the first and third slots will find the names of all the properties that the specified object has which have that value . // returns list of all object ids and the values of theie date_born properties WOQL.triple(&#39;v:Object ID&#39;, &#39;date_born&#39;, &#39;v:Date of Births&#39;) . Putting variables in the second and third slot find all the properties and their values for the object with the specified ID: . WOQL.triple(&#39;joe&#39;, &#39;v:Joes Properties&#39;, &quot;v:Property Values&quot;) . The third and final pattern is easiest still - putting variables in all 3 of the slots will match every single triple in the database. In fact, because this is so useful, WOQL provides a special built in shortcut for generating this pattern: . //generates a triple query with variables in all 3 spots - returns all triples in the database WOQL.star() . Logical Operators . Single triple pattern matching like the above is certainly neat, but there’s a limited number of things that can be expressed as a single pattern of triples, even with all our variables turned on. However, WOQL also provides logical operators, AND, OR which allow you to combine as many basic patterns as you like into incredibly expressive queries in very simple forms. . The most useful operator is logical AND - WOQL.and() which behaves as we would logically expect - if all of the patterns defined within a WOQL.and() can be filled by the database, all of the results will be returned, otherwise, no results will be returned. . The other basic logical operators: OR - WOQL.or() and NOT - WOQL.not() are also very useful - they are interpreted also as expected - in the first case, the query will return the first result that it matches in a list of possibilities, in the second case, the query will only return true if the pattern specified is not found in the database. . Below are some simple examples of using these logical operators in practice. It is amazing how many things you can readily express simply by combining these patterns in different ways. Extreme simplicity and absolute regularity in the little things allow extreme elegance of description in the big things. . That’s not all folks . One other huge advantage of a simple and regular underlying architecture is that it becomes much easier to build extra functionality on top. In addition to the basic ideas presented here, WOQL also has a broad set of built-in operators and libraries which cover arithmetic, mathematical, date and time, taxonomy specific patterns, aggregation, ordering, grouping, geographical and a wide range of other functions out of the box. This allows you to move a lot of your logic into the Database Layer and out of your application code - the database should be the only thing that cares about the structure of the storage layer, the rest of us care about getting the data we want out! . The rest of this chapter contains lots of information about all the functions and operators that WOQL provides and how you can access them, but before you leave, we have a question to ask. . I want to ask my database for the full records of all living people whose direct ancestors were born in Italy before 1850 (assuming I have the records of course) along with their lineage. . In WOQL my query would look like this: . WOQL.(&quot;v:Living Person Record ID&quot;, &quot;status&quot;, &quot;alive&quot;) .path(&quot;v:Living Person Record ID&quot;, &quot;parent+&quot;, &quot;v:Italian Ancestor&quot;, &quot;v:Ancestry Line&quot;) .triple(&quot;v:Italian Ancestor&quot;, &quot;date_born&quot;, &quot;v:Date of Birth&quot;) .less(&quot;v:Date of Birth&quot;, 1850) .triple(&quot;v:Italian Ancestor&quot;, &quot;country_born&quot;, &quot;Italy&quot;) .get_object(&quot;v:Living Person Record ID&quot;, &quot;v:Full Record&quot;) . How would you ask your database this question? .",
    "url": "/docs/discussion/query/",
    "relUrl": "/discussion/query/"
  }
  ,"41": {
    "title": "Query",
    "content": "Query . TerminusDB allows you to query graphs in either Javascript or Python. This tutorial is about using Javascript, which is the method which is available in the console. . . Open a Database | First steps | Viewing the schema | Combining Queries | Manipulating text | Mathematics | Manipulate Data Inserting | Deleting | | Conclusion | . Open a Database . First you’ll need a database which you can query. You can get started by opening TerminusDB and going to the clone page. . From there you should select “TerminusDB Bikes Tutorial”, and clone it to your local machine. . Once you’ve cloned it, you should be opened up into the WordNet database automatically. Click on the Query button. . First steps . Graph databases are made up out of edges in a graph. You can query these edges by using the word triple (a triple is a source node, a named edge and a target node). Now, the WordNet graph is fairly large, so we’ll also need to limit our queries to make sure we get something manageable to look at. We can do that with limit. . Try out the following query in the query box: . let [subject, predicate, object] = vars(&#39;subject&#39;,&#39;predicate&#39;,&#39;object&#39;) limit(1).triple(subject,predicate,object) . This query just gets back any random edge without any constraints. But graphs are about connections, so we should make a query that goes more than one hop in order to find something interesting. In this case we just get back the triple: . X P Y . doc:Bicycle_W00017 | rdf:type | scm:Bicycle | . If we want to use the graph aspects, we have to create chains: . let [subject, predicate1, intermediate, predicate2, object] = vars(&#39;subject&#39;,&#39;predicate1&#39;,&#39;intermediate&#39;,&#39;predicate2&#39;,&#39;object&#39;) limit(1).triple(subject,predicate1,intermediate) .triple(intermediate,predicate2,object) . This is a two-hop query, so now we are actually exploring the graph a bit. . First, let’s do a little exploration to see what is in the database. As it turns out, predicates are not as common as source or target nodes (subjects or objects). . We can see all of the predicates using the following query: . let [subject, predicate, object] = vars(&#39;subject&#39;,&#39;predicate&#39;,&#39;object&#39;) distinct(predicate) .select(predicate) .triple(subject,predicate,object) . This query selects only the predicates (it masks out the other variables) and ensures that we only get distinct predicates. You’ll notice that there are two in particular: scm:start_station and scm:end_station. We’ll come back to those in a moment. . Viewing the schema . If you click on the schema tab, you’ll be able to peruse the object types and predicates which are available to you in any database which uses a schema. . [image here] . There are several tabs, Classes, Properties, Graphs, Triples and Prefixes. The Triples tab will give you access to the raw OWL schema information, which is also editable. . [image here] . But for our purposes we just need to know what properties are available. Here we can see that scm:start_station and scm:end_station have a scm:Journey as the domain, and scm:Station as a range. This means that our journey object specifies where we started and where we end up. . Combining Queries . The basic building block of a query in TerminusDB is the triple. In order to combine them we tend to build up graph fragments in which we use the same variable at each node that we want to be the same. We then combine these triples with and. We call this repeated variable use for matching unification. . Let’s look at our scm:Journey’s using and: . let [journey,start_station,end_station] = vars(&#39;journey&#39;,&#39;start_station&#39;,&#39;end_station&#39;) limit(10) .and( triple(journey,&#39;scm:start_station&#39;,start_station) triple(journey,&#39;scm:end_station&#39;,end_station) ) . This query gives us back the end points of our journey. However, it isn’t terribly informative as we are only given identifiers (IRIs) which are opaque. We can however, expand the query to ask for the names of these stations: . let [journey, journey_name ] = vars(&#39;journey&#39;, &#39;journey_name&#39;) let [start_station, start_name] = vars(&#39;start_station&#39;, &#39;start_name&#39;) let [end_station, end_name] = vars(&#39;end_station&#39;, &#39;end_name&#39;) limit(10) .and( triple(journey,&#39;scm:start_station&#39;,start_station), triple(journey, &#39;label&#39;, journey_name), triple(start_station, &#39;label&#39;, start_name), triple(journey,&#39;scm:end_station&#39;,end_station), triple(end_station, &#39;label&#39;, end_name) ) . Perfect! Now we see the named location of these bike stations. However, we also have a fair bit of extra information so we can filter that out again with a select statement. . let [journey, journey_name ] = vars(&#39;journey&#39;, &#39;journey_name&#39;) let [start_station, start_name] = vars(&#39;start_station&#39;, &#39;start_name&#39;) let [end_station, end_name] = vars(&#39;end_station&#39;, &#39;end_name&#39;) limit(10).select(journey_name,start_name,end_name) .and( triple(journey,&#39;scm:start_station&#39;,start_station), triple(journey, &#39;label&#39;, journey_name), triple(start_station, &#39;label&#39;, start_name), triple(journey,&#39;scm:end_station&#39;,end_station), triple(end_station, &#39;label&#39;, end_name) ) . Now we have something a little bit more human readable. Perhaps you can try looking at the properties and adding additional information. . We can also ask questions where we want either/or type results. For this, we can use the WOQL word or. We could ask, for instance, for every journey which started from a station or ended at that station as follows: . let [journey, journey_name ] = vars(&#39;journey&#39;, &#39;journey_name&#39;) let [some_station, some_station_name] = vars(&#39;some_station&#39;, &#39;some_station_name&#39;) limit(10).select(journey_name,some_station_name) .and( or( triple(journey,&#39;scm:start_station&#39;,some_station), triple(journey,&#39;scm:end_station&#39;,some_station) ), triple(journey, &#39;label&#39;, journey_name), triple(some_station, &#39;label&#39;, some_station_name) ) . This gives us back journeys which have to do with a station either entering or leaving. . Manipulating text . When you’re querying you’ll often need to manipulate the text in entries. WOQL has a number of words for helping you parse and reassemble text. . One of the most flexible ways of finding and parsing text is to use the re WOQL word. Supposing we want to find every journey starting from a station on 10th street. We could run the following: . let [journey, journey_name ] = vars(&#39;journey&#39;, &#39;journey_name&#39;) let [start_station, start_name] = vars(&#39;start_station&#39;, &#39;start_name&#39;) let [match] = vars(&#39;match&#39;) limit(1).and( triple(journey, &quot;scm:start_station&quot;, start_station), triple(start_station, &#39;label&#39;, start_name), re(&quot;.*10th.*&quot;, start_name, [match]) ) . This is great, but perhaps we want to say what the other corner street was. We can do this by adding matching groups with ( and ): . let [journey, journey_name ] = vars(&#39;journey&#39;, &#39;journey_name&#39;) let [start_station, start_name] = vars(&#39;start_station&#39;, &#39;start_name&#39;) let [match,other] = vars(&#39;match&#39;, &#39;other&#39;) and( triple(journey, &quot;scm:start_station&quot;, start_station), triple(start_station, &#39;label&#39;, start_name), or( re(&quot;^(.*) . 10th.*$&quot;, start_name, [match, other]), re(&quot;^10th . (.*)$&quot;, start_name, [match, other]) ) ) . This gives us back every journey which started at any station on 10th street. . Once we have these strings, we might want to use them to put together new strings. Let’s add a message to our report about 10th street. . let [journey, journey_name ] = vars(&#39;journey&#39;, &#39;journey_name&#39;) let [start_station, start_name] = vars(&#39;start_station&#39;, &#39;start_name&#39;) let [match,other] = vars(&#39;match&#39;, &#39;other&#39;) let [message] = vars(&#39;message&#39;) select(message).distinct(message).and( triple(journey, &quot;scm:start_station&quot;, start_station), triple(start_station, &#39;label&#39;, start_name), or( re(&quot;^(.*) . 10th.*$&quot;, start_name, [match, other]), re(&quot;^10th . (.*)$&quot;, start_name, [match, other]) ), concat([&quot;The other street is: &quot;,other], message) ) . The use of distinct here gives us a nice summary view, along with your message. . Mathematics . You may also want to perform some mathematical operations on data going into or out of the database. WOQL has basic mathematical expressions: plus, multiply, divide, exp, div (for integer division) and others. To use them you need to put the mathematical expression in a form called WOQL.eval as follows: . let [ x ] = vars(&#39;x&#39;) WOQL.eval(plus(1,2), x) . This binds x to the result of the addition of 1 and 2. You can use variables in place of 1 and 2 and re-use x in later queries. For instance we could write: . let [product,result] = vars(&#39;product&#39;, &#39;result&#39;) and( WOQL.eval(times(3,2), product), WOQL.eval(div(product,2), result) ) . Here of course we get back the number 3 as we’d expect. The complete definition of mathematical operators is in the python-client reference documentation. . Manipulate Data . WOQL has various ways to manipulate data, which you can do from the console query page. Since in TerminusDB all changes are append-only, this will create a new commit describing all the additions and removals your query did. . When manipulating data from the query screen, you need to specify a reason for your update in the text bar at the top of the query pane. This message will be used as the commit message. . Inserting . add_triple(&quot;doc:a&quot;,&quot;scm:b&quot;,&quot;doc:c&quot;) . This will insert the triple (&quot;doc:a&quot;,&quot;scm:b&quot;,&quot;doc:c&quot;). . Deleting . delete_triple(&quot;doc:a&quot;,&quot;scm:b&quot;,&quot;doc:c&quot;) . This will delete the triple (&quot;doc:a&quot;,&quot;scm:b&quot;,&quot;doc:c&quot;). . Conclusion . Now you’ve a few tricks under your belt, you should be able to explore some of the datasets available on TerminusHub or your own data a bit. Happy WOQLing! .",
    "url": "/docs/how-tos/query/",
    "relUrl": "/how-tos/query/"
  }
  ,"42": {
    "title": "Quickstart Academy",
    "content": "Quickstart Academy . . What is TerminusDB and what does it do? . TerminusDB is an open-source general purpose graph database that stores data like Git. It is built for data people and allows fierce data integration, versioning out of the box and unparalleled query. No data platform is more productive. . TerminusDB allows for the whole suite of revision control features: branch, merge, squash, rollback, blame, and time-travel. . Download in our download center . . What is TerminusHub and how does it work? . TerminusDBs are linked through TerminusHub. The hub allows the user to manage access to databases and to collaboratively work on shared resources. You can make changes to a database, push them to hub and have a collaborator pull the synced version of the database. . You can share and collaborate on curated data sets in a distributed manner using git-like operations (push, pull, fetch, clone, fork) . Collaboration is easy with clone/fork allowing data to be moved to your cloud or servers . Merge and branch operations let you mix and match data sources significantly simplifying integration tasks. . More information and set up an account . . Quickstart Tutorials . My first shared database - this is a quick tutorial to introduce you to sharing databases with TerminusDB and TerminusHub. This tutorial uses the console to create a database with a schema and then share the database using TerminusHub. . link . . My first cloned database - introduction to cloning a database on TerminusHub. There are several curated datasets available on TerminusHub that you can quickly clone. This tutorial will show you how to clone a database in TerminusDB and Hub console. Once you have downloaded TerminusDB and set up your account, cloning a database should take less than a minute. . link . . Quickstart How-To . Link to download center . Link to other ways of installing .",
    "url": "/docs/quickstart/",
    "relUrl": "/quickstart/"
  }
  ,"43": {
    "title": "Research Papers",
    "content": "Research Papers . Data Engineering Lifecycle . TerminusDB came out of a European research project on data engineering lifecycles. This culminated in the first version of TerminusDB as well as a book on Engineering Agile Big-Data Systems. . Succinct Datastructures . TerminusDB utilises some novel approaches to Database architecture which encorporate succinct data-structures. You can find more about our representation of graphs in Succinct Data Structures and Delta Encoding for Modern Databases. .",
    "url": "/docs/discussion/reserach/",
    "relUrl": "/discussion/reserach/"
  }
  ,"44": {
    "title": "Create Schema",
    "content": "Create Schema . . Creating a Schema | Graph Schemas | Cardinality | Schema migration | Creating hierarchies | . Creating a Schema . The easiest way to create a schema in TerminusDB is by using a WOQL query. . First thing, you should create a database in which to put the schema. You can do this through the console. . Our schema is comprised of classes and properties. WOQL will allow us to construct them with the WOQL.doctype keyword. . WOQL.doctype(&quot;Person&quot;) .label(&quot;Person&quot;) .description(&quot;A Person with person-like properties&quot;) .property(&quot;forename&quot;, &quot;xsd:string&quot;) .property(&quot;surname&quot;, &quot;xsd:string&quot;) .property(&quot;age&quot;, &quot;xsd:integer&quot;) . This object has 3 properties, with three different datatypes. It is essentially a simple record. . The data which can be put into this object should look something like the following: . WOQL.and( WOQL.add_triple(&quot;doc:jim_martin&quot;, &quot;type&quot;, &quot;scm:Person&quot;), WOQL.add_triple(&quot;doc:jim_martin&quot;, &quot;forename&quot;, &quot;Jim&quot;), WOQL.add_triple(&quot;doc:jim_martin&quot;, &quot;surname&quot;, &quot;Martin&quot;), WOQL.add_triple(&quot;doc:jim_martin&quot;, &quot;age&quot;, 38) ) . This query will insert a valid record for our class above. As you can see we are only pointing at datapoints at the moment, but we can also have properties point to other objects. . Graph Schemas . We can go ahead and modify the previous query by adding a scm:friends_with field. As long as we’re only adding things, there is no problem repeating assertions we’ve already made. So we’ll just copy the person from above and try again. . WOQL.doctype(&quot;Person&quot;) .label(&quot;Person&quot;) .description(&quot;A Person with person-like properties&quot;) .property(&quot;forename&quot;, &quot;xsd:string&quot;) .property(&quot;surname&quot;, &quot;xsd:string&quot;) .property(&quot;age&quot;, &quot;xsd:integer&quot;) .property(&quot;friends_with&quot;, &quot;Person&quot;) . You can go ahead and go to the Schema button at the top, and you’ll see that there is still only one Person class. All we did is suggest that the “friends_with” property should be added. . Now we can add a couple of people and have them point to each other. . WOQL.and( WOQL.add_triple(&quot;doc:sarah_cohen&quot;, &quot;type&quot;, &quot;scm:Person&quot;), WOQL.add_triple(&quot;doc:sarah_cohen&quot;, &quot;forename&quot;, &quot;Sara&quot;), WOQL.add_triple(&quot;doc:sarah_cohen&quot;, &quot;surname&quot;, &quot;Cohen&quot;), WOQL.add_triple(&quot;doc:sarah_cohen&quot;, &quot;age&quot;, 42), WOQL.add_triple(&quot;doc:sarah_cohen&quot;, &quot;friends_with&quot;, &quot;doc:jim_martin&quot;), WOQL.add_triple(&quot;doc:jim_martin&quot;, &quot;friends_with&quot;, &quot;doc:sarah_cohen&quot;) ) . Our schema as designed allows us to control the types of fields. We can see this by trying to put in some data which is not correct according to the schema. . WOQL.add_triple(&quot;doc:sarah_cohen&quot;, &quot;forename&quot;, &quot;doc:jim_martin&quot;) . This gives us a predictable error that jim is not a string. . However, as scm:Person is currently written we do not constraint the number of times a property is used. For instance we can write: . WOQL.and( WOQL.add_triple(&quot;doc:jim_martin&quot;, &quot;type&quot;, &quot;scm:Person&quot;), WOQL.add_triple(&quot;doc:jim_martin&quot;, &quot;forename&quot;, &quot;Jim&quot;), WOQL.add_triple(&quot;doc:jim_martin&quot;, &quot;forename&quot;, &quot;James&quot;), WOQL.add_triple(&quot;doc:jim_martin&quot;, &quot;surname&quot;, &quot;Martin&quot;), WOQL.add_triple(&quot;doc:jim_martin&quot;, &quot;age&quot;, 38) ) . Cardinality . Jim now has two names. Maybe we want this, but perhaps we want a formal legal forename, and we constraint his aliases to something called scm:nick for instance. . Let’s rewrite our person to add cardinality restrictions on the properties. . WOQL.doctype(&quot;Person&quot;) .label(&quot;Person&quot;) .description(&quot;A Person with person-like properties&quot;) .property(&quot;forename&quot;, &quot;xsd:string&quot;).cardinality(1) .property(&quot;surname&quot;, &quot;xsd:string&quot;).cardinality(1) .property(&quot;nickname&quot;, &quot;xsd:string&quot;) .property(&quot;age&quot;, &quot;xsd:integer&quot;).cardinality(1) .property(&quot;friends_with&quot;, &quot;Person&quot;) . Now we have an unconstrained “scm:friends_with” relationship and any number of nicknames on the “scm:nickname” property but we can only have one of each of the other properties. . Schema migration . Unfortunately, this query results in an error because we have data already in our system which does not conform to our schema changes. We need to alter the data to make it conform. We can simply remove the offending forename in the same stroke that we add the schema change. . WOQL.and( WOQL.delete_triple(&quot;doc:jim_martin&quot;, &quot;forename&quot;, &quot;James&quot;), WOQL.doctype(&quot;Person&quot;) .label(&quot;Person&quot;) .description(&quot;A Person with person-like properties&quot;) .property(&quot;forename&quot;, &quot;xsd:string&quot;).cardinality(1) .property(&quot;surname&quot;, &quot;xsd:string&quot;).cardinality(1) .property(&quot;nickname&quot;, &quot;xsd:string&quot;) .property(&quot;age&quot;, &quot;xsd:integer&quot;).cardinality(1) .property(&quot;friends_with&quot;, &quot;Person&quot;) ) . Now we have added cardinality and removed the violation in a single transaction. . Creating hierarchies . So far, we have a very flat structure. Let’s add a subclass for scm:Person called scm:Doctor. . WOQL.doctype(&quot;Doctor&quot;) .parent(&quot;Person&quot;) .label(&quot;Doctor&quot;) .description(&quot;A Doctor is a person with patients&quot;) .property(&quot;patient&quot;, &quot;Person&quot;) . A doctor shares all of the properties available to a Person, but it also has a patient. Let us add a Doctor. . WOQL.and( WOQL.add_triple(&quot;doc:sigmund_freud&quot;, &quot;type&quot;, &quot;scm:Doctor&quot;), WOQL.add_triple(&quot;doc:sigmund_freud&quot;, &quot;forename&quot;, &quot;Freud&quot;), WOQL.add_triple(&quot;doc:sigmund_freud&quot;, &quot;surname&quot;, &quot;Sigmund&quot;), WOQL.add_triple(&quot;doc:sigmund_freud&quot;, &quot;age&quot;, 51), WOQL.add_triple(&quot;doc:sarah_cohen&quot;, &quot;friends_with&quot;, &quot;doc:sigmund_freud&quot;), WOQL.add_triple(&quot;doc:sigmund_freud&quot;, &quot;friends_with&quot;, &quot;doc:sarah_cohen&quot;), WOQL.add_triple(&quot;doc:sigmund_freud&quot;, &quot;patient&quot;, &quot;doc:jim_martin&quot;) ) . This saved us a lot of time as we factored out the joint qualities of a person first. You can make any sort of hierarchy without worrying about multiple inheritence restrictions that often occur in other systems. . Good luck schema-writing! .",
    "url": "/docs/how-tos/schema/",
    "relUrl": "/how-tos/schema/"
  }
  ,"45": {
    "title": "My First Shared Database",
    "content": "My First Shared Database . This is a quick tutorial to introduce you to sharing databases with TerminusDB and TerminusHub. This tutorial uses the console and has installed TerminusDB using bootstrap. . . Step 1 - Connect to Hub . Go to the TerminusDB home page and click Connect to Hub to login to your TerminusHub account. . . Once you have logged in, click Create . . Step 2 - Create a Database . You will arrive on the create database screen. As this is a tutorial explaining how to share databases with TerminusDB and Hub, you should create the database on TerminusHub. You will also need to name the database and give it an ID. You can also indicate if the database will be public or private and if you need to include a schema. The default is a public database with a schema. You can elect to include a picture or an icon to associate with the database. . . For this example, we have named the database test and given the ID test1 . . Once you have created the database, you will find the DB Home screen. Click on Query so we can update the database prior to sharing. . . This uses a quick query to insert a doctype into the database. We use WOQL.doctype(&quot;test&quot;) . Once you have run the query, you can check the schema to make sure the doctype is inserted . . Step 3 - Sync and Share . Now that we have something in the database, click on the Synchronize tab. You can now push your changes to TerminusHub so that collaborators and others can access your changes. . . Now click on the TerminusDB button in the top right to return to the home page. Once there, click Collaborate so we can share the database. . . On the collaboration page, use the Collaborative Actions dropdown to select Add Collaborators. On this page, you can assign collaborative permissions (read, write or manage) and add the user ID or email address of your collaborators (these can be separated by a comma if more than one). . In this case, I am giving manage permissions to my collaborator ‘lf’ and sending a message to explain my action. . . This was successfully shared with user ‘lf’ . . User ‘lf’ can now login and see that the database has been shared with them. . . Finally, we can now revisit the Collaboration page and see that the list of invited collaborators has been updated with the relevant information: . . That’s how easy it is to share databases with TerminusDB and TerminusHub. Feel free to use my ID (‘luke’ or ‘lf’) when trying it out. . Enjoy! .",
    "url": "/docs/tutorials/share-tutorial/",
    "relUrl": "/tutorials/share-tutorial/"
  }
  ,"46": {
    "title": "Storage",
    "content": "Storage . TerminusDB is architected as a revision controlled database from the ground up. In TerminusDB, revision control is based on a model quite similar to the one used in git. However, where git uses lines of code added or deleted, TerminusDB uses triples added or deleted. . . Each collection of additions and deletions is called a delta or delta layer. These deltas are then appended together in a chain (or tree) to form what is the current state of our graph. This approach of always giving the changed information as a delta makes TerminusDB an append-only database. . When we query for data, we start at the top of the stack, and search downwards looking for triples added, which have not been deleted. . Each graph represents sets of triples. That is, a triple is either there, or it is not. There is no notion of it being in the graph multiple times. This simplifies our model of changes, merges and updates. . Architecture . . TerminusDB is structured as a hierarchy of graphs. Each level of the hierarchy is itself a graph which can be queried and which stores information about the graphs below it. . At the highest level is the TerminusCore graph. This stores the records concerning all users and databases in the system. . For each database, there is a corresponding “_meta” graph which stores information about which repositories are present for a database. This includes at least the “local” repository. However, it may also contain any number of remote repositories as well. These remotes represent other TerminusDB installations and can be used to push or pull changes and collaborate with others. . Each of these repositories consists of a “_commit” graph which stores information about the branches that we have, commit chains, and the graphs associated with each commit. . Finally, commits point to the instance and schema graphs associated with a commit. This is important since schema and instance graphs have to move in lock-step to maintain consistency. . We will look more closely at the commit-graph and then move on to the various operations which TerminusDB can perform. . Here are some posts: . TerminusDB: Database Architecture . . | TerminusDB: Internals . . |",
    "url": "/docs/discussion/storage/",
    "relUrl": "/discussion/storage/"
  }
  ,"47": {
    "title": "Store",
    "content": "Store . . Overview | Layers | Labels | Version information | . Overview . In a TerminusDB installation, data is stored under the storage/db directory. This section contains a reference of the files that are found there, and what purpose they serve. . For a better idea of how this actually works, please check out the whitepaper. For the documentation of the underlying rust storage library, check out the terminusdb-store library documentation. . Layers . TerminusDB is an append-only database. This means that when you delete some triples, these triples aren’t actually deleted from disk. Instead, all changes are stored as a layer. . Layers have a 160 bit id that is used to refer to them. On disk, layers are stored in a directory under this id, represented as a 40 character hexadecimal number. These directories are further grouped into directories named after the first 3 characters of this hexadecimal number. For example, if there is a layer with id ‘0123456789abcdef0123456789abcdef01234567’, it can be found in the directory ‘storage/db/012/0123456789abcdef0123456789abcdef01234567’. . A layer directory contains a set of files to represent this layer. The set of files depends on whether this is a base layer or a child layer. A base layer has no parent, and only has triple additions. All triple data structures will be prefixed with base_. A child layer does have a parent (referred to in ‘parent.hex’), and contains both triple additions (files prefixed with pos_) and triple removals (files prefixed with neg_). In addition, child layers store a list of all subjects and objects added and removed in that layer, meaning, if any triple was added with a particular subject, that subject will be stored in the child_pos_subject.logarray file, and similarly for child_neg_subject.logarray, child_pos_object.logarray and child_neg_object.logarray. . All data files mentioned so far refer to nodes, predicates and values with a numerical id. Layers also contain dictionary files to translate from a string representation of a node, predicate or value, to a numerical id and back. These files are the same for base and child layers. All node dictionary files are prefixed with node_dictionary_, all predicate dictionary files are prefixed with predicate_dictionary_ and all value dictionary files are prefixed with value_dictionary_. Unlike triples, dictionary entries are never removed, so these files always describe additions to the dictionary. . Each file has an extension describing what kind of data structure it is. There are 4 file extensions: . .pfc files are plain front coding dictionary files. | .logarray files are compressed arrays of numbers. | .bitarray files are arrays of bits. | .hex files contain a hexadecimal number. | . Labels . Labels are used to track changes to named graphs. They link a name to a particular layer id. Labels can be updated to point them at another layer, which is how all updates in the system are done. . Labels are stored in files with the .label file extension. All these files can be found directly in the storage/db directory. . Label files contain two lines of data: . an update number, saying how often this file was updated | a layer id | . A freshly initialized terminusdb-server will already contain some label files. Most of these describe schemas for various internal graphs: . http%3a%2f%2fterminusdb.com%2fschema%2flayer.label: layer schema (a schema used in any graph that refers to terminusdb layers, namely the commit graph and the repository metadata graph). | http%3a%2f%2fterminusdb.com%2fschema%2fref.label: commit graph schema. | http%3a%2f%2fterminusdb.com%2fschema%2frepository.label: repository metadata schema. | terminusdb%3a%2f%2f%2fsystem%2fschema.label: system graph schema. | . Additionally, there’s one so-called inference graph here: terminusdb%3a%2f%2f%2fsystem%2finference.label. This label points at a graph describing inference rules for the system graph. Inference rules are currently an undocumented feature of TerminusDB, which is nevertheless used in some internal graphs. . Finally, there’s a label for the system graph: terminusdb%3a%2f%2f%2fsystem%2fdata.label. The system graph contains information about all users, organizations and databases in the system. . For every created database, an additional label file will be created. This file will be named {organization}%7c{dbname}.label (%7c is the url-encoded version of the pipe character |). This label will point at the repository metadata graph for that database. This graph itself internally points at commit graphs, which themselves in turn point at data graphs. . Version information . The storage/db directory contains one final file: SERVER_VERSION. This file contains a version number, which terminusdb-server uses to keep track of the storage version. This number will be raised any time a backwards-incompatible change is made. If this number does not match what the server expects, the server will refuse to start. .",
    "url": "/docs/reference/server/store/",
    "relUrl": "/reference/server/store/"
  }
  ,"48": {
    "title": "Synchronising Changes",
    "content": "Synchronizing Changes . Sharing databases and updates to databases is easy with TerminusDB and TerminusHub. We call this pulling and pushing changes: you pull updates from TerminusHub to your local version and push changes from your local version to TerminusHub. This makes collaboration and synchronization easy. . . Pull . You can pull changes which were made on hub by selecting pull. . First, enter a database. Go to the synchronize tab on your database. . Press the pull button and you can pull the data from the remote database . . Push . Push is similar. Once you have made your changes, push the changes to the remote so others can access the latest version of the database. . Press the Push button on the synchronize page. . . You will see a success notification once you have pushed to the remote. .",
    "url": "/docs/how-tos/synchronise/",
    "relUrl": "/how-tos/synchronise/"
  }
  ,"49": {
    "title": "Time Travel",
    "content": "Time Travel . TerminusDB is a temporal database and natively supports time travel. It offers temporal data types and stores information relating to the past states of the database. TerminusDB uses a delta encoding approach to facilitate time travel queries. You can read more about this in this technical white paper. . This How To uses the console. . . Section 1 - Go to Database . Login to TerminusHub and clone a database, or you can use a database you created or uploaded. This How To uses the bike share database available on TerminusHub. . . This will take you to the ‘DB Home’ screen, which contains all the relevant metadata about the database. . . Section 2 - Time Travel . Go to the schema page and use the ‘Latest’ toggle in the top right to open the time travel widget. Once the widget is open, you can travel to any point in the history of the database using the slider bar or the calendar. When you have found the point you want to return to, just click ‘Time Travel to this Commit’ and you will move to that point. The schema will then reflect that state. You can always travel back to the head of the database should you need to. . . The time travel widget work throughout the console. Click on the ‘Branch’ tab and select ‘Branch’ - the time travel widget appears automatically on this page to allow you to travel to any point in the history of the database and easily take a branch from there. You may wish to only have the data and schema from before a specific date. This makes it easy to use the time travel and branch features together. . Just use the slider and calendar to find the relevant point, input a ‘New Branch ID’ and click ‘Create New Branch’. . . And remember faster than light travel is time travel. .",
    "url": "/docs/how-tos/time-travel/",
    "relUrl": "/how-tos/time-travel/"
  }
  ,"50": {
    "title": "Upgrade",
    "content": "Upgrade from older versions . . The current version of TerminusDB is 3.0. Currently, there is no way to automatically upgrade to 3.0. We intend to release a migration tool with our next minor release. . Manual upgrade . If you currently have a 2.x instance and wish to migrate your data, you can attempt to do so manually. . Starting from version 3.0, the primary branch of a database is no longer called ‘master’, but is instead called ‘main’. This means that, upon starting 3.0 with an old 2.x store, none of your databases will have a primary branch anymore, which may result in unexpected behavior. . You can resolve this issue for individual databases by manually creating the ‘main’ branch by branching off ‘master’. Having done so, your database once again has a primary branch, and no unexpected behavior should occur. . Have a look at this blog to see the reason we made the change. . Assistance . Maybe you’re unsure about doing the manual upgrade, but do not wish to wait for the next minor release for the automatic upgrade path. If that is the case, do not hesitate to get in touch with us! You can reach us on our community forum and on our discord server. You can find out more on our [community page](Instructions for joining). .",
    "url": "/docs/release-notes/upgrade/",
    "relUrl": "/release-notes/upgrade/"
  }
  ,"51": {
    "title": "WOQL",
    "content": "WOQL . This is the JSON-LD definition of the WOQL language. Those wishing to implement clients for TerminusDB should construct JSON-LD messages according to this ontology. . . Terminus DB WOQL Query Syntax Schema (http://terminusdb.com/schema/woql) Class: Node (woql:Node) Super classes | Property: node (woql:node) Range: (owl:Thing) | | | Class: Variable (woql:Variable) Super classes | Property: Variable Name (woql:variable_name) Range: (xsd:string) | | | Class: Array Element (woql:ArrayElement) Super classes | | Class: Node (woql:Datatype) Super classes | Property: datatype (woql:datatype) Range: (xsd:anySimpleType) | | | Class: Indexable (woql:Indexable) Super classes | Property: index (woql:index) Range: (xsd:nonNegativeInteger) | | | Class: Query (woql:Query) Super classes | Property: document (woql:document) Range: (owl:Thing) | | | Class: query list element (woql:QueryListElement) Super classes | | Class: Query with indexable sub query (woql:QueryWithIndexedSubQuery) Super classes | Property: query list (woql:query_list) Range: query list element (woql:QueryListElement) | | | Class: Query With Subquery (woql:QueryWithSubQuery) Super classes | Property: (woql:query) Range: Query (woql:Query) | | | Class: And (woql:And) Super classes | | Class: Using (woql:Comment) Super classes | Property: comment (woql:comment) Range: (xsd:string) | | | Class: From (woql:From) Super classes | | Class: Into (woql:Into) Super classes | | Class: Or (woql:Or) Super classes | | Class: Query with graph (woql:QueryWithGraph) Super classes | Property: graph (woql:graph) Range: (xsd:string) | | | Class: Query with graph filter (woql:QueryWithGraphFilter) Super classes | Property: graph filter (woql:graph_filter) Range: (xsd:string) | | | Class: Select (woql:Select) Super classes | | Class: Using (woql:Using) Super classes | Property: Collection (woql:collection) Range: (xsd:string) | | | Class: Variable List Element (woql:VariableListElement) Super classes | | Class: Binary Operator (woql:BinaryOperator) Super classes | Property: left (woql:left) Range: (woql:Value) | | Property: right (woql:right) Range: (woql:Value) | | | Class: Equals (woql:Equals) Super classes | | Class: Quad (woql:Quad) Super classes | | Class: Substring (woql:Substring) Super classes | Property: after (woql:after) Range: (woql:Value) | | Property: before (woql:before) Range: (woql:Value) | | Property: string (woql:string) Range: (woql:Value) | | Property: substring (woql:substring) Range: (woql:Value) | | | Class: Subsumption (woql:Subsumption) Super classes | Property: child (woql:child) Range: (owl:Thing) | | Property: parent (woql:parent) Range: (owl:Thing) | | | Class: Triple (woql:Triple) Super classes | | Class: Document Query (woql:DocumentQuery) Super classes | | Class: Read Object (woql:ReadObject) Super classes | | Class: Add quad (woql:AddQuad) Super classes | | Class: Add triple (woql:AddTriple) Super classes | | Class: Value (woql:ArithmeticValue) Super classes | | Class: As Var (woql:AsVar) Super classes | Property: var type (woql:var_type) Range: (xsd:string) | | | Class: Binary Arithmetic Operator (woql:BinaryArithmeticOperator) Super classes | Property: first (woql:first) Range: Arithmetic Expression (woql:ArithmeticExpression) | | Property: second (woql:second) Range: Arithmetic Expression (woql:ArithmeticExpression) | | | Class: Concatenate (woql:Concatenate) Super classes | Property: list (woql:concat_list) Range: (woql:Value) | | Property: concatcatenated (woql:concatenated) Range: (woql:Value) | | | Class: Delete Object (woql:DeleteObject) Super classes | | Class: Delete quad (woql:DeleteQuad) Super classes | | Class: Delete triple (woql:DeleteTriple) Super classes | | Class: Div (woql:Div) Super classes | | Class: Divide (woql:Divide) Super classes | | Class: Eval (woql:Eval) Super classes | Property: expression (woql:expression) Range: Arithmetic Expression (woql:ArithmeticExpression) | | Property: result (woql:result) Range: (woql:Value) | | | Class: Exp (woql:Exp) Super classes | | Class: File Query Resource (woql:FileResource) Super classes | Property: file (woql:file) Range: (xsd:string) | | | Class: Floor (woql:Floor) Super classes | | Class: Get (woql:Get) Super classes | | Class: Get or Put (woql:GetOrPut) Super classes | Property: as vars (woql:as_vars) Range: As Var (woql:AsVar) | | Property: resource (woql:query_resource) Range: Query Resource (woql:QueryResource) | | | Class: Greater (woql:Greater) Super classes | | Class: Group By (woql:GroupBy) Super classes | Property: grouped (woql:group_by) Range: Variable List Element (woql:VariableListElement) | | Property: grouped (woql:group_template) Range: Variable List Element (woql:VariableListElement) | | Property: group var (woql:grouped) Range: (woql:Value) | | | Class: ID Gen (woql:IDGenerator) Super classes | | Class: Is A (woql:IsA) Super classes | Property: element (woql:element) Range: (owl:Thing) | | Property: of type (woql:of_type) Range: (owl:Thing) | | | Class: Join (woql:Join) Super classes | Property: join (woql:join) Range: (woql:Value) | | Property: join list (woql:join_list) Range: (woql:Value) | | Property: join separator (woql:join_separator) Range: (woql:Value) | | | Class: Length (woql:Length) Super classes | Property: list (woql:length_list) Range: (woql:Value) | | | Class: Less (woql:Less) Super classes | | Class: Like (woql:Like) Super classes | Property: similarity (woql:like_similarity) Range: (woql:Value) | | | Class: limit (woql:Limit) Super classes | Property: limit (woql:limit) Range: (woql:Value) | | | Class: Lower (woql:Lower) Super classes | | Class: Minus (woql:Minus) Super classes | | Class: A var by column or header name (woql:NamedAsVar) Super classes | Property: identifier (woql:identifier) Range: (xsd:string) | | | Class: Not (woql:Not) Super classes | | Class: Optional (woql:Optional) Super classes | | Class: Order By (woql:OrderBy) Super classes | Property: Variable Array (woql:variable_ordering) Range: Variable Ordering (woql:VariableOrdering) | | | Class: Pad (woql:Pad) Super classes | Property: pad char (woql:pad_char) Range: (woql:Value) | | Property: pad result (woql:pad_result) Range: (woql:Value) | | Property: pad string (woql:pad_string) Range: (woql:Value) | | Property: pad times (woql:pad_times) Range: (woql:Value) | | | Class: Plus (woql:Plus) Super classes | | Class: Post Query Resource (woql:PostResource) Super classes | | Class: Put (woql:Put) Super classes | | Class: regexp (woql:Regexp) Super classes | Property: pattern (woql:pattern) Range: (woql:Value) | | Property: list (woql:regexp_list) Range: (woql:Value) | | Property: string (woql:regexp_string) Range: (woql:Value) | | | Class: Remote Query Resource (woql:RemoteResource) Super classes | Property: remote uri (woql:remote_uri) Range: (xsd:anyURI) | | | Class: Split (woql:Split) Super classes | Property: split list (woql:split_list) Range: (woql:Value) | | Property: split pattern (woql:split_pattern) Range: (woql:Value) | | Property: split string (woql:split_string) Range: (woql:Value) | | | Class: start (woql:Start) Super classes | | Class: Sum (woql:Sum) Super classes | Property: start (woql:start) Range: (woql:Value) | | Property: sum (woql:sum) Range: (woql:Value) | | Property: sum list (woql:sum_list) Range: (woql:Value) | | | Class: Times (woql:Times) Super classes | | Class: True (woql:True) Super classes | | Class: Typecast (woql:Typecast) Super classes | Property: typecast result (woql:typecast_result) Range: (woql:Value) | | Property: typecast type (woql:typecast_type) Range: (woql:Value) | | Property: typecast value (woql:typecast_value) Range: (woql:Value) | | | Class: URI Generator (woql:URIGenerator) Super classes | Property: base (woql:base) Range: (woql:Value) | | Property: key list (woql:key_list) Range: Value List (woql:ValueList) | | Property: base (woql:uri) Range: (woql:Value) | | | Class: Binary Arithmetic Operator (woql:UnaryArithmeticOperator) Super classes | Property: argument (woql:argument) Range: Arithmetic Expression (woql:ArithmeticExpression) | | | Class: Unique (woql:Unique) Super classes | | Class: Update Object (woql:UpdateObject) Super classes | | Class: Upper (woql:Upper) Super classes | | Class: Value List Element (woql:ValueListElement) Super classes | | Class: Variable Ordering (woql:VariableOrdering) Super classes | Property: Ascending (woql:ascending) Range: (xsd:boolean) | | | Class: When (woql:When) Super classes | Property: consequent (woql:consequent) Range: Query (woql:Query) | | | Class: Dot (woql:Dot) Super classes | Property: dictionary (woql:dictionary) Range: (woql:Value) | | Property: key (woql:dictionary_key) Range: (woql:Value) | | Property: value (woql:dictionary_value) Range: (woql:Value) | | | Class: Plus (woql:Edge) Super classes | | Class: Has a resource (woql:HasResource) Super classes | Property: resource (woql:resource) Range: (xsd:string) | | | Class: Path (woql:Path) Super classes | Property: path (woql:path) Range: Path Pattern (woql:PathPattern) | | | Class: Sequence (woql:PathOr) Super classes | Property: left (woql:path_left) Range: Path Pattern (woql:PathPattern) | | Property: right (woql:path_right) Range: Path Pattern (woql:PathPattern) | | | Class: Plus (woql:PathPlus) Super classes | | Class: Predicate (woql:PathPredicate) Super classes | Property: first (woql:path_predicate) Range: (owl:Thing) | | | Class: Sequence (woql:PathSequence) Super classes | Property: first (woql:path_first) Range: Path Pattern (woql:PathPattern) | | Property: second (woql:path_second) Range: Path Pattern (woql:PathPattern) | | | Class: Star (woql:PathStar) Super classes | | Class: Plus (woql:PathTimes) Super classes | Property: maximum (woql:path_maximum) Range: (xsd:nonNegativeInteger) | | Property: minimum (woql:path_minimum) Range: (xsd:nonNegativeInteger) | | | Class: Size (woql:Size) Super classes | Property: size (woql:size) Range: (woql:Value) | | | Class: Size (woql:TripleCount) Super classes | Property: triple count (woql:triple_count) Range: (woql:Value) | | | | . Terminus DB WOQL Query Syntax Schema (http://terminusdb.com/schema/woql) . Authors: Gavin Mendel-Gleason Kevin C. Feeney . Schema describing all the structure of the WOQL query language . Class: Node (woql:Node) . An arbitrary node identifier . Super classes . (woql:NodeRestriction) | . Property: node (woql:node) . Range: (owl:Thing) . The URI of an object of an edge . Class: Variable (woql:Variable) . A WOQL logic variable . Super classes . (woql:VariableNameRestriction) | . Property: Variable Name (woql:variable_name) . Range: (xsd:string) . A name for the variable . Class: Array Element (woql:ArrayElement) . Box for an element of an array . Super classes . Indexable (woql:Indexable) | (woql:IndexableRestriction) | (woql:Value) | . Class: Node (woql:Datatype) . An arbitrary node identifier . Super classes . (woql:DatatypeRestriction) | . Property: datatype (woql:datatype) . Range: (xsd:anySimpleType) . The datatype value of an object of an edge . Class: Indexable (woql:Indexable) . Something with an index . Super classes . (woql:IndexableRestriction) | . Property: index (woql:index) . Range: (xsd:nonNegativeInteger) . The index of a list . Class: Query (woql:Query) . A WOQL Query . Super classes . Document Class (system:Document) | . Property: document (woql:document) . Range: (owl:Thing) . Document associated with a query . Class: query list element (woql:QueryListElement) . An element of a list of queries . Super classes . Document Class (system:Document) | Indexable (woql:Indexable) | (woql:IndexableRestriction) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Class: Query with indexable sub query (woql:QueryWithIndexedSubQuery) . A Query with an indexed sub-query . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: query list (woql:query_list) . Range: query list element (woql:QueryListElement) . A list of queries . Class: Query With Subquery (woql:QueryWithSubQuery) . A WOQL Query with a subquery . Super classes . Document Class (system:Document) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | . Property: (woql:query) . Range: Query (woql:Query) . Class: And (woql:And) . A conjunction of clauses . Super classes . Document Class (system:Document) | Query (woql:Query) | Query with indexable sub query (woql:QueryWithIndexedSubQuery) | . Class: Using (woql:Comment) . Introduce a default collection. {‘@type’ : ‘Comment’, ‘comment’ : collection_descriptor} . Super classes . Document Class (system:Document) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Property: comment (woql:comment) . Range: (xsd:string) . A comment . Class: From (woql:From) . A query with a graph filter for selection . Super classes . Document Class (system:Document) | Query (woql:Query) | Query with graph filter (woql:QueryWithGraphFilter) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Class: Into (woql:Into) . A query with a graph for selection . Super classes . Document Class (system:Document) | Query (woql:Query) | Query with graph (woql:QueryWithGraph) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Class: Or (woql:Or) . A disjunction of clauses . Super classes . Document Class (system:Document) | Query (woql:Query) | Query with indexable sub query (woql:QueryWithIndexedSubQuery) | . Class: Query with graph (woql:QueryWithGraph) . A query with a specified graph . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: graph (woql:graph) . Range: (xsd:string) . the string to form a graph descriptor . Class: Query with graph filter (woql:QueryWithGraphFilter) . A query with a graph filter . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: graph filter (woql:graph_filter) . Range: (xsd:string) . the string to form a graph filter descriptor . Class: Select (woql:Select) . A Selection of variables from subquery . Super classes . Document Class (system:Document) | Has Variable List (woql:HasVariableList) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Class: Using (woql:Using) . Introduce a default collection. {‘@type’ : ‘Using’, ‘collection’ : collection_descriptor, ‘query’ : query} . Super classes . Document Class (system:Document) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Property: Collection (woql:collection) . Range: (xsd:string) . A collection . Class: Variable List Element (woql:VariableListElement) . An element of a list by position . Super classes . Indexable (woql:Indexable) | (woql:IndexableRestriction) | Variable (woql:Variable) | (woql:VariableNameRestriction) | . Class: Binary Operator (woql:BinaryOperator) . A binary operator, with left and right . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: left (woql:left) . Range: (woql:Value) . The left of a Binary Operator . Property: right (woql:right) . Range: (woql:Value) . The right of a Binary Operator . Class: Equals (woql:Equals) . Defines unification between two things . Super classes . Document Class (system:Document) | Binary Operator (woql:BinaryOperator) | Query (woql:Query) | . Class: Quad (woql:Quad) . A triple with graph filter . Super classes . Document Class (system:Document) | Object (woql:HasObject) | Predicate (woql:HasPredicate) | Subject (woql:HasSubject) | Query (woql:Query) | Query with graph filter (woql:QueryWithGraphFilter) | Triple (woql:Triple) | . Class: Substring (woql:Substring) . Find substrings of a given string . Super classes . Document Class (system:Document) | HasLength (woql:HasLength) | Query (woql:Query) | . Property: after (woql:after) . Range: (woql:Value) . The after characters index of a substring search . Property: before (woql:before) . Range: (woql:Value) . The before characters index of a substring search . Property: string (woql:string) . Range: (woql:Value) . The string of a substring search . Property: substring (woql:substring) . Range: (woql:Value) . The substring of a substring search . Class: Subsumption (woql:Subsumption) . Subsumption of one class by another . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: child (woql:child) . Range: (owl:Thing) . The child of a subsumption . Property: parent (woql:parent) . Range: (owl:Thing) . The parent of a subsumption . Class: Triple (woql:Triple) . A edge in the graph specified by subject, predicate, object . Super classes . Document Class (system:Document) | Object (woql:HasObject) | Predicate (woql:HasPredicate) | Subject (woql:HasSubject) | Query (woql:Query) | . Class: Document Query (woql:DocumentQuery) . A query which references a document . Super classes . Document Class (system:Document) | Query (woql:Query) | . Class: Read Object (woql:ReadObject) . Read an object as JSON . Super classes . Document Class (system:Document) | Document Query (woql:DocumentQuery) | Query (woql:Query) | . Class: Add quad (woql:AddQuad) . Add a quad . Super classes . Document Class (system:Document) | Object (woql:HasObject) | Predicate (woql:HasPredicate) | Subject (woql:HasSubject) | Query (woql:Query) | Query with graph (woql:QueryWithGraph) | Triple (woql:Triple) | . Class: Add triple (woql:AddTriple) . Add a triple . Super classes . Document Class (system:Document) | Object (woql:HasObject) | Predicate (woql:HasPredicate) | Subject (woql:HasSubject) | Query (woql:Query) | Triple (woql:Triple) | . Class: Value (woql:ArithmeticValue) . An arithmetic value - float, int, bignum, etc. . Super classes . (woql:Value) | . Class: As Var (woql:AsVar) . As Var . Super classes . Variable (woql:Variable) | (woql:VariableNameRestriction) | . Property: var type (woql:var_type) . Range: (xsd:string) . An AsVar casting type . Class: Binary Arithmetic Operator (woql:BinaryArithmeticOperator) . Binary Arithmetic Operator . Super classes . Arithmetic Expression (woql:ArithmeticExpression) | . Property: first (woql:first) . Range: Arithmetic Expression (woql:ArithmeticExpression) . The first argument of a binary operator . Property: second (woql:second) . Range: Arithmetic Expression (woql:ArithmeticExpression) . The second argument of a binary operator . Class: Concatenate (woql:Concatenate) . Concatenate a list of strings . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: list (woql:concat_list) . Range: (woql:Value) . The list of elements to concatenate . Property: concatcatenated (woql:concatenated) . Range: (woql:Value) . The string which has been concatenated . Class: Delete Object (woql:DeleteObject) . Delete an object as JSON . Super classes . Document Class (system:Document) | Document Query (woql:DocumentQuery) | Query (woql:Query) | . Class: Delete quad (woql:DeleteQuad) . Delete a quad . Super classes . Document Class (system:Document) | Object (woql:HasObject) | Predicate (woql:HasPredicate) | Subject (woql:HasSubject) | Query (woql:Query) | Query with graph (woql:QueryWithGraph) | Triple (woql:Triple) | . Class: Delete triple (woql:DeleteTriple) . Delete a triple . Super classes . Document Class (system:Document) | Object (woql:HasObject) | Predicate (woql:HasPredicate) | Subject (woql:HasSubject) | Query (woql:Query) | Triple (woql:Triple) | . Class: Div (woql:Div) . Integer division . Super classes . Arithmetic Expression (woql:ArithmeticExpression) | Binary Arithmetic Operator (woql:BinaryArithmeticOperator) | . Class: Divide (woql:Divide) . Arithmetic division . Super classes . Arithmetic Expression (woql:ArithmeticExpression) | Binary Arithmetic Operator (woql:BinaryArithmeticOperator) | . Class: Eval (woql:Eval) . Eval an arithmetic expression . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: expression (woql:expression) . Range: Arithmetic Expression (woql:ArithmeticExpression) . The arithmetic expression under evaluation . Property: result (woql:result) . Range: (woql:Value) . Class: Exp (woql:Exp) . Arithmetic exponentiation . Super classes . Arithmetic Expression (woql:ArithmeticExpression) | Binary Arithmetic Operator (woql:BinaryArithmeticOperator) | . Class: File Query Resource (woql:FileResource) . A File Query Resource . Super classes . Query Resource (woql:QueryResource) | . Property: file (woql:file) . Range: (xsd:string) . File associated with a query resource . Class: Floor (woql:Floor) . The floor of a floating point number . Super classes . Arithmetic Expression (woql:ArithmeticExpression) | Binary Arithmetic Operator (woql:UnaryArithmeticOperator) | . Class: Get (woql:Get) . Get variable bindings from a resource . Super classes . Document Class (system:Document) | Get or Put (woql:GetOrPut) | Query (woql:Query) | . Class: Get or Put (woql:GetOrPut) . Abstract class for Get or Put . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: as vars (woql:as_vars) . Range: As Var (woql:AsVar) . The variable captures associated with a get . Property: resource (woql:query_resource) . Range: Query Resource (woql:QueryResource) . A resource for woql:Get . Class: Greater (woql:Greater) . One value greater than another . Super classes . Document Class (system:Document) | Binary Operator (woql:BinaryOperator) | Query (woql:Query) | . Class: Group By (woql:GroupBy) . Group a query by a spec . Super classes . Document Class (system:Document) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Property: grouped (woql:group_by) . Range: Variable List Element (woql:VariableListElement) . Variable in which to place the grouping . Property: grouped (woql:group_template) . Range: Variable List Element (woql:VariableListElement) . Variable in which to place the grouping . Property: group var (woql:grouped) . Range: (woql:Value) . Variable which to group . Class: ID Gen (woql:IDGenerator) . A reversible unique identifier generated from a Base and a Key . Super classes . Document Class (system:Document) | Query (woql:Query) | URI Generator (woql:URIGenerator) | . Class: Is A (woql:IsA) . Check that Object ‘is a’ Type . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: element (woql:element) . Range: (owl:Thing) . The element of an IsA being type checked . Property: of type (woql:of_type) . Range: (owl:Thing) . Element is ‘of type’ . Class: Join (woql:Join) . Join a list of strings . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: join (woql:join) . Range: (woql:Value) . The join of the list . Property: join list (woql:join_list) . Range: (woql:Value) . The list of things to be joined . Property: join separator (woql:join_separator) . Range: (woql:Value) . The separator in a join list . Class: Length (woql:Length) . Find the length of a collection . Super classes . Document Class (system:Document) | HasLength (woql:HasLength) | Query (woql:Query) | . Property: list (woql:length_list) . Range: (woql:Value) . The thing of which we want a length . Class: Less (woql:Less) . One value less than another . Super classes . Document Class (system:Document) | Binary Operator (woql:BinaryOperator) | Query (woql:Query) | . Class: Like (woql:Like) . An element is like another element . Super classes . Document Class (system:Document) | Binary Operator (woql:BinaryOperator) | Query (woql:Query) | . Property: similarity (woql:like_similarity) . Range: (woql:Value) . The similarity value (between 0 and 1) . Class: limit (woql:Limit) . A query limited by number of results . Super classes . Document Class (system:Document) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Property: limit (woql:limit) . Range: (woql:Value) . The limit of results to obtain . Class: Lower (woql:Lower) . Lowercase string left to string right . Super classes . Document Class (system:Document) | Binary Operator (woql:BinaryOperator) | Query (woql:Query) | . Class: Minus (woql:Minus) . Arithmetic subtraction . Super classes . Arithmetic Expression (woql:ArithmeticExpression) | Binary Arithmetic Operator (woql:BinaryArithmeticOperator) | . Class: A var by column or header name (woql:NamedAsVar) . A var by column or header name . Super classes . As Var (woql:AsVar) | Variable (woql:Variable) | (woql:VariableNameRestriction) | . Property: identifier (woql:identifier) . Range: (xsd:string) . Identifier for a column name . Class: Not (woql:Not) . Not the query . Super classes . Document Class (system:Document) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Class: Optional (woql:Optional) . Query which is optional . Super classes . Document Class (system:Document) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Class: Order By (woql:OrderBy) . Order a queries results by the given list . Super classes . Document Class (system:Document) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Property: Variable Array (woql:variable_ordering) . Range: Variable Ordering (woql:VariableOrdering) . An array of variables . Class: Pad (woql:Pad) . Pad a string with character C, N times, to get a result . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: pad char (woql:pad_char) . Range: (woql:Value) . Character with which to pad to string . Property: pad result (woql:pad_result) . Range: (woql:Value) . Result of padding . Property: pad string (woql:pad_string) . Range: (woql:Value) . String to pad . Property: pad times (woql:pad_times) . Range: (woql:Value) . Number of times to pad woql:pad_char . Class: Plus (woql:Plus) . Arithmetic addition . Super classes . Arithmetic Expression (woql:ArithmeticExpression) | Binary Arithmetic Operator (woql:BinaryArithmeticOperator) | . Class: Post Query Resource (woql:PostResource) . An HTTP POST Query Resource . Super classes . File Query Resource (woql:FileResource) | Query Resource (woql:QueryResource) | . Class: Put (woql:Put) . Put some variables bindings in a defined resource . Super classes . Document Class (system:Document) | Get or Put (woql:GetOrPut) | Query (woql:Query) | . Class: regexp (woql:Regexp) . A regular expression and its results . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: pattern (woql:pattern) . Range: (woql:Value) . The pattern to match . Property: list (woql:regexp_list) . Range: (woql:Value) . The list of results matched in the pattern . Property: string (woql:regexp_string) . Range: (woql:Value) . The string to match against pattern . Class: Remote Query Resource (woql:RemoteResource) . A Query Resource . Super classes . Query Resource (woql:QueryResource) | . Property: remote uri (woql:remote_uri) . Range: (xsd:anyURI) . Remote URI associated with a query resource . Class: Split (woql:Split) . split string on pattern result . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: split list (woql:split_list) . Range: (woql:Value) . List of splits from string . Property: split pattern (woql:split_pattern) . Range: (woql:Value) . Pattern on which to split a string . Property: split string (woql:split_string) . Range: (woql:Value) . String to split . Class: start (woql:Start) . The starting point in result set . Super classes . Document Class (system:Document) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Class: Sum (woql:Sum) . Sum of a list of numbers . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: start (woql:start) . Range: (woql:Value) . The number from which to start . Property: sum (woql:sum) . Range: (woql:Value) . The sum of the list . Property: sum list (woql:sum_list) . Range: (woql:Value) . The list of things to be summed . Class: Times (woql:Times) . Arithmetic multiplication . Super classes . Arithmetic Expression (woql:ArithmeticExpression) | Binary Arithmetic Operator (woql:BinaryArithmeticOperator) | . Class: True (woql:True) . Always true . Super classes . Document Class (system:Document) | Query (woql:Query) | . Class: Typecast (woql:Typecast) . A typecast of a variable to a new type . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: typecast result (woql:typecast_result) . Range: (woql:Value) . The casted value . Property: typecast type (woql:typecast_type) . Range: (woql:Value) . The type we want to typecast to . Property: typecast value (woql:typecast_value) . Range: (woql:Value) . The thing of which we want a typecast . Class: URI Generator (woql:URIGenerator) . A Generator for IDs . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: base (woql:base) . Range: (woql:Value) . The document base of a URI . Property: key list (woql:key_list) . Range: Value List (woql:ValueList) . The key list of a URI . Property: base (woql:uri) . Range: (woql:Value) . The document base of a URI . Class: Binary Arithmetic Operator (woql:UnaryArithmeticOperator) . Binary Arithmetic Operator . Super classes . Arithmetic Expression (woql:ArithmeticExpression) | . Property: argument (woql:argument) . Range: Arithmetic Expression (woql:ArithmeticExpression) . The argument of a unary operator . Class: Unique (woql:Unique) . An irreversible unique identifier generated from a Base and a Key . Super classes . Document Class (system:Document) | Query (woql:Query) | URI Generator (woql:URIGenerator) | . Class: Update Object (woql:UpdateObject) . Update an object as JSON . Super classes . Document Class (system:Document) | Document Query (woql:DocumentQuery) | Query (woql:Query) | . Class: Upper (woql:Upper) . Uppercase string left to string right . Super classes . Document Class (system:Document) | Binary Operator (woql:BinaryOperator) | Query (woql:Query) | . Class: Value List Element (woql:ValueListElement) . A Value List Element . Super classes . Indexable (woql:Indexable) | (woql:IndexableRestriction) | (woql:Value) | . Class: Variable Ordering (woql:VariableOrdering) . A specific variable to de used in ordering . Super classes . Indexable (woql:Indexable) | (woql:IndexableRestriction) | Variable (woql:Variable) | Variable List Element (woql:VariableListElement) | (woql:VariableNameRestriction) | . Property: Ascending (woql:ascending) . Range: (xsd:boolean) . Should the ordering be ascending . Class: When (woql:When) . When A, do B . Super classes . Document Class (system:Document) | Query (woql:Query) | (woql:QueryWithSingleSubQuery) | Query With Subquery (woql:QueryWithSubQuery) | . Property: consequent (woql:consequent) . Range: Query (woql:Query) . The consequence of a woql:When . Class: Dot (woql:Dot) . Select from a dictionary . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: dictionary (woql:dictionary) . Range: (woql:Value) . Dictionary of a selection . Property: key (woql:dictionary_key) . Range: (woql:Value) . Dictionary key of a selection . Property: value (woql:dictionary_value) . Range: (woql:Value) . Dictionary value of a selection . Class: Plus (woql:Edge) . Follow pattern at least once . Super classes . Object (woql:HasObject) | Predicate (woql:HasPredicate) | Subject (woql:HasSubject) | . Class: Has a resource (woql:HasResource) . Has a graph or collection resource descriptor . Super classes . Document Class (system:Document) | Query (woql:Query) | . Property: resource (woql:resource) . Range: (xsd:string) . A graph or collection resource descriptor . Class: Path (woql:Path) . A path query . Super classes . Document Class (system:Document) | Object (woql:HasObject) | Has Pattern (woql:HasPathPattern) | Subject (woql:HasSubject) | Query (woql:Query) | . Property: path (woql:path) . Range: Path Pattern (woql:PathPattern) . The path taken by a pattern . Class: Sequence (woql:PathOr) . path_first followed by path_second . Super classes . Path Pattern (woql:PathPattern) | . Property: left (woql:path_left) . Range: Path Pattern (woql:PathPattern) . The left branch pattern in a fork . Property: right (woql:path_right) . Range: Path Pattern (woql:PathPattern) . The right branch pattern in a fork . Class: Plus (woql:PathPlus) . Follow pattern at least once . Super classes . Has Pattern (woql:HasPathPattern) | Path Pattern (woql:PathPattern) | . Class: Predicate (woql:PathPredicate) . Contains a predicate to follow in a pattern . Super classes . Path Pattern (woql:PathPattern) | . Property: first (woql:path_predicate) . Range: (owl:Thing) . Pattern to deploy first in a sequence . Class: Sequence (woql:PathSequence) . path_first followed by path_second . Super classes . Path Pattern (woql:PathPattern) | . Property: first (woql:path_first) . Range: Path Pattern (woql:PathPattern) . Pattern to deploy first in a sequence . Property: second (woql:path_second) . Range: Path Pattern (woql:PathPattern) . Pattern to deploy second in a sequence . Class: Star (woql:PathStar) . Follow pattern any number of times (including the empty transition) . Super classes . Has Pattern (woql:HasPathPattern) | Path Pattern (woql:PathPattern) | . Class: Plus (woql:PathTimes) . Follow pattern at least once . Super classes . Has Pattern (woql:HasPathPattern) | Path Pattern (woql:PathPattern) | . Property: maximum (woql:path_maximum) . Range: (xsd:nonNegativeInteger) . Maximum applications of pattern. . Property: minimum (woql:path_minimum) . Range: (xsd:nonNegativeInteger) . Minumum applications of pattern. . Class: Size (woql:Size) . Size of a resource . Super classes . Document Class (system:Document) | Has a resource (woql:HasResource) | Query (woql:Query) | . Property: size (woql:size) . Range: (woql:Value) . Calculated size of a graph or collection resource . Class: Size (woql:TripleCount) . Size of a resource . Super classes . Document Class (system:Document) | Has a resource (woql:HasResource) | Query (woql:Query) | . Property: triple count (woql:triple_count) . Range: (woql:Value) . Triple count of a graph or collection resource .",
    "url": "/docs/reference/server/woql/",
    "relUrl": "/reference/server/woql/"
  }
  ,"52": {
    "title": "WOQL.js - the Definitive Guide",
    "content": ". | Fluent Style | WOQL.js and JSON-LD Embedding JSON-LD directly in WOQL.js | | WOQL Variables | Prefixes in WOQL.js | WOQL Functions | . Fluent Style . The TerminusDB query libraries make extensive use of the fluent style to simplify the expression of complex compound queries. Many WOQL query words accept a sub-query as an argument and, rather than using a functional (Lisp-like) style of capturing containment, a style where sub-queries are appended to the initial function as a new function is preferred. . rather than using a functional style: . select(a, b, triple(c, d, e)) . the fluent style would be: . select(a, b).triple(c, d, e) . Both styles are legal WOQL and semantically equivalent. However, the second ‘fluent’ style is preferred because it is easier to read and easier to write primarily becaue it greatly reduces the amount of vizual parameter matching that the reader and writer have to perform in order to verify that their query is correct. . Fluent queries are parsed left to right - functions to the right of a given function are considered as sub-queries of the first, with one important exception - conjunction. . the functional style of expresing conjunction using the WOQL and() function is straightforward and is often most useful for clarity: . and(triple(a, b, c), triple(d, e, f)) . the fluent style allows us to use any of the following forumlations with the same semantics: . and(triple(a, b, c)).triple(d, e, f) triple(a, b, c).and().triple(d, e, f) triple(a, b, c).triple(d, e, f) . The third concise form is unambiguous in situations where the WOQL functions that are chained together do not take sub-clauses - and because conjunction is so frequently used, this short-hand form, where the and() is implicit, is convenient in many situations. However it should be used with care - the conjunction is always applied to the function immediately to the left of the ‘.’ in the chain and not to any functions further up the chain. If used improperly, with clauses that do take sub-clauses, it will produce improperly specified queries, in particular with negation (not) and optional functions (opt). . So, for example, the following query: . triple(a, b, c).opt().triple(d, e, f).triple(g, h, i) . is equivalent to the following query in the functional style: . and( triple(a, b, c), opt( and( triple(d, e, f), triple(g, h, i) ) ) ) . It is easy to misinterpret it when you mean to express: . and( triple(a, b, c), opt().triple(d, e, f), triple(g, h, i) ) . As a general rule, if in doubt, use the functional style explicitly with and() as this makes it clear and explicit which functions are sub-clauses of other functions. . WOQL.js and JSON-LD . WOQL uses JSON-LD and a formally specified ontology to define the language and to transmit queries over the wire. WOQL.js is designed primarily to be as easy as possible for programmers to write because JSON-LD is itself tedious for humans to read and write. All WOQL.js queries are translated into the equivalent JSON-LD format for transmission over the wire. The WOQL.js json() function can be used to translate any WOQL query from its JSON-LD format to and from it’s WOQL.js equivalent (a WOQLQuery() object). If passed a JSON-LD argument, it will generate the equivalent WOQLQuery() object, if passed no argument, it will return the JSON-LD equivalent of the WOQLQuery(), in general the following semantic identity should always hold: . let wjs = new WOQLQuery().json(json_ld) json_ld == wjs.json() . Embedding JSON-LD directly in WOQL.js . It is possible to use JSON-LD interchangably within WOQL.js - wherever a WOQL function or argument can be accepted directly in WOQL.js, the JSON-LD equivalent can also be supplied. So, for example, the following two WOQL statements are identical: . triple(a, b, 1) == triple(a, b, {&quot;@type&quot;: &quot;xsd:integer&quot;, &quot;@value&quot;: 1}) . There should never be a situation in which it is necessary to use JSON-LD directly - WOQL.js is sufficiently rich to express all queries that are expressible in the underlying JSON-LD, however it can be convenient to embed JSON-LD in queries in some cases. . WOQL Variables . With the exception of resource identifiers which are used to specify the graphs against which operations such as queries are carried out (functions: using, with, into, from), WOQL allows variables to be substituted for any of the arguments to all WOQL functions. WOQL variables follow the logic of unification - borrowed from the Prolog engine which implements WOQL within TerminusDB. That is to say that each valid value for a variable, as constrained by the totality of the query, will produce a new row in the results, and when there are multiple variables, the rows that are returned will be the cartesian product of all the possible combinations of variables values in the query. . In WOQL.js, there are 3 distinct ways of expressing variables within queries. All are semantically equivalent, although the first is generally preferred as it is easier to type and it is easier to distinguish variables from constants at a glance due to the lack of quote marks around the variables . 1 . let [a, b, c] = vars(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) triple(a, b, c) . 2 . triple(&#39;v:a&#39;, &#39;v:b&#39;, &#39;v:c&#39;) . 3 . triple({&#39;@type&#39;: &#39;woql:Variable&#39;, &#39;woql:variable_name&#39;: {&quot;@type&quot;: &#39;xsd:string&#39;, &#39;@value&#39;: &#39;a&#39;}} ....) . WOQL uses the formal logical approach to variables known as unification - this allows most WOQL functions to serve as both pattern matchers and pattern generators, depending on whether a variable or constant is provided as an argument. If a variable is provided, WOQL will generate all possible valid solutions which fill the variable value. If a constant is provided, WOQL will match only those solutions with exactly that value. With the exception of resource identifiers, WOQL functions accept either variables or constants in virtually all of their arguments. . Prefixes in WOQL.js . Internally, TerminusDB uses strict RDF rules to represent all data. This means that all identifiers and properties are represented by IRIs (which are a superset of URLs). However, IRIs are difficult to remember and tedious to type. RDF in general gets around this problem by allowing prefixed forms as shorthand - so for example, we can use “rdf:type” rather than “http://obscure.w3c.url/with/embedded/dates#type”. TerminusDB defines a set of standard prefixes which are availabe to use and also allows users to extend this by adding their own prefix designations to the system. The set of standard prefixes includes the basic language elements (rdf, rdfs, owl), datatype elements (xsd, xdd) and internal namespaces (ref, repo, system, vio). It also pre-defines two prefixes for user-use - the ‘doc’ prefix for instance data IRIs and the ‘scm’ prefix for schema IRIs. So we can write “doc:X” or “scm:X” and this will always resolve to a valid IRI in all databases. . WOQL goes a step beyond supporting prefixes and automatically applies prefixes wherever possible allowing users to specify prefixes only when necessary. . The default prefixes are applied in the following way - “doc” applies to woql:subject (first argument to triple) where instance data IRIs are normally what is required - “scm” applies to woql:predicate and other arguments (sub, type) where schema elements are normally required - when standard predicates are used with no prefix (label, type, comment, subClassOf, domain, range) the standard correct prefixes are applied - otherwise if no prefix is applied a string is assumed . WOQL Functions . The JSON-LD form of WOQL supports a well-defined set of functions (woql:Triple, woql:Regexp…) - in WOQL.js these functions are known as primitives. WOQL.js supports all of these primite functions and adds several extensions on top - functions that compose multiple primitives, functions that compose partial primitives and can be chained together, and simple helper functions to make it easier to format the arguments correctly. The table below shows the full range of functions supported by WOQL.js and groups them together into categories to make it easier to find the required function for specific problems. .",
    "url": "/docs/reference/woql",
    "relUrl": "/reference/woql"
  }
  
}